<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Grid App</title>

  <meta property="og:type" content="website">
  <meta property="og:url" content="https://tomerrrr-create.github.io/color-grid-app/">
  <meta property="og:title" content="Your power is your Intuition">
  <meta property="og:description" content="Drift in a waterfall of colors🌈">
  <meta property="og:image" content="https://raw.githubusercontent.com/tomerrrr-create/color-grid-app/refs/heads/main/og.PNG">
  <meta property="og:locale" content="he_IL" />

  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://tomerrrr-create.github.io/color-grid-app/">
  <meta name="twitter:title" content="Your power is your Intuition">
  <meta name="twitter:description" content="Drift in a waterfall of colors🌈">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/tomerrrr-create/color-grid-app/refs/heads/main/og.PNG">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    /* Custom properties for dynamic styling controlled by JS */
    :root {
      --grid-size: 5;
      --gap-px: 6px;
      --tile-radius: 2px;
      /* New design tokens */
      --icon-size: 26px;
      --save-dot-size: 10px;
      --stroke: 3px;
      --gold: #FFD700;

      /* Reserved vertical space for the 3-row controls block (safe, conservative) */
      /* 3*50px buttons + ~16px row gaps + ~44px top margin (mt-11) + misc spacing */
      --controls-block: 240px;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(var(--grid-size), 1fr);
      gap: var(--gap-px);
      border-width: var(--gap-px);
      border-radius: 6px;
      -webkit-user-select: none; /* Prevents text selection in Safari (iOS) */
      user-select: none;          /* Prevents text selection in modern browsers */
    }
    .tile {
      border-radius: var(--tile-radius);
      transition: background-color 0.4s ease, box-shadow 0.2s ease;
    }
    
    /* --- CONTROL BUTTON STYLES --- */
    #controls {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      column-gap: 12px; /* Horizontal gap */
      row-gap: 8px;     /* Vertical gap - Reduced */
      width: fit-content; /* Ensure grid doesn't stretch */
    }
    .ctrl {
      width: 50px;
      height: 50px;
      cursor: pointer;
      user-select: none;
      outline: none;
      background: transparent;
      border: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      position: relative;
      touch-action: manipulation; /* Prevents double-tap to zoom on iOS */
      transition: opacity 0.2s ease-in-out;
    }

    /* שמירה על סגנון הפוקוס לנגישות בכל המכשירים */
    .ctrl:focus-visible {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.25);
      border-radius: 8px;
    }

    /* החלת סגנון הריחוף רק במכשירים שיכולים לרחף (לא מכשירי מגע) */
    @media (hover: hover) {
      .ctrl:hover {
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.25);
        border-radius: 8px;
      }
    }

    .ctrl:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        box-shadow: none;
    }
    .glyph {
      width: var(--icon-size);
      height: var(--icon-size);
      display: inline-block;
      position: relative;
    }
    .ctrl svg {
        width: var(--icon-size);
        height: var(--icon-size);
    }
    .glyph-square-gold {
      background: #000;
      border: 2px solid var(--gold);
      box-sizing: border-box;
      border-radius: 2px;
    }
    .glyph-square-white {
      background: #000;
      border: 2px solid #fff;
      box-sizing: border-box;
      border-radius: 2px;
    }
    .glyph-random {
      background: linear-gradient(90deg, #000 50%, #fff 50%);
      border-radius: 50%;
    }
    .glyph-remix {
      background: linear-gradient(90deg, #fff 50%, #000 50%);
      border-radius: 50%;
    }
    .palette {
      font-size: var(--icon-size);
      line-height: 1;
    }
    .save { 
        background: transparent; 
        border: none; 
        position: absolute;
        left: 0;
        top: 25px; /* Vertically centers with first row's center */
        transform: translateY(-50%);
    }
    .save::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      width: var(--save-dot-size);
      height: var(--save-dot-size);
      margin-left: calc(var(--save-dot-size) / -2);
      margin-top: calc(var(--save-dot-size) / -2);
      background: #fff;
      border-radius: 50%;
    }
    
    /* Brush Mode Button Style */
    #btnBrushMode svg path {
        transition: fill 0.2s ease-in-out;
    }
    #btnBrushMode.brush-on svg path {
        fill: #fff;
    }

    /* Tile Highlight Styles */
    .tile.source-highlight {
        box-shadow: 0 0 0 4px var(--gold) inset;
    }
    .tile.target-highlight {
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8) inset;
    }

    /* Ensure the board never steals vertical space reserved for controls */
    .app-shell {
      /* The board is square because tiles are square; control width to control height */
      width: min(85vmin, 720px, calc(100vh - var(--controls-block)));
    }

    @media (max-width: 480px) {
      .ctrl { width: 44px; height: 44px; }
      #controls {
        grid-template-columns: repeat(3, 44px);
        grid-template-rows: repeat(3, 44px);
      }
      .save {
          top: 22px; /* Adjust for smaller button size */
      }
    }
  </style>
</head>
<body class="bg-black text-[#eaeaea] font-sans">

  <div class="min-h-screen flex flex-col items-center justify-start p-6 pt-10 sm:pt-12">
    <div class="w-full max-w-[720px] mx-auto app-shell">
      
      <div id="board" class="board bg-black border-black touch-none" aria-label="לוח צבעים" role="grid"></div>

      <div class="mt-11 relative">
        <button id="btnSave" class="ctrl save" aria-label="Save" title="Save"></button>
        <div id="controls" class="mx-auto" aria-label="Control buttons">
            <button id="btnRandom" class="ctrl" aria-label="Randomize Palette" title="Randomize Palette">
                <span class="glyph glyph-random" aria-hidden="true"></span>
            </button>
            <button id="btnPalette" class="ctrl palette" aria-label="Switch palette" title="Switch palette"></button>
            <button id="btnRemix" class="ctrl" aria-label="Remix current Grid" title="Remix current Grid">
                <span class="glyph glyph-remix" aria-hidden="true"></span>
            </button>
            
            <button id="btnResetGold" class="ctrl" aria-label="Reset" title="Reset">
                <span class="glyph glyph-square-gold" aria-hidden="true"></span>
            </button>
            <button id="btnGap" class="ctrl" aria-label="Grid Separator" title="Grid Separator">
                <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" aria-hidden="true">
                  <path d="M8 3v18M16 3v18M3 8h18M3 16h18"/>
                </svg>
            </button>
            <button id="btnResize" class="ctrl" aria-label="Resize" title="Resize">
                <span class="glyph glyph-square-white" aria-hidden="true"></span>
            </button>

            <button id="btnUndo" class="ctrl" aria-label="Undo" title="Undo">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M3 10v4c0 1.1.9 2 2 2h7"/>
                    <path d="M3 10l4-4 4 4"/>
                </svg>
            </button>
            <button id="btnBrushMode" class="ctrl" title="Mode: Drag to Copy">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 2 L2 22 L22 22 Z" stroke="#fff" stroke-width="2" fill="#000" />
                </svg>
            </button>
            <button id="btnRedo" class="ctrl" aria-label="Redo" title="Redo">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M21 10v4c0 1.1-.9 2-2 2h-7"/>
                    <path d="M21 10l-4-4-4 4"/>
                </svg>
            </button>
        </div>
      </div>

    </div>
  </div>

  <script>
    (function() {
      const PALETTES = [
        { name: 'Default', emoji: '🌓', colors: ['#FFD700','#FFC107','#FFEE58','#FDD835','#FBC02D','#FFE082','#FFCA28','#FFF176','#FF8C00','#FF9800','#FB8C00','#FFA726','#FF7043','#FF5722','#F4511E','#F57C00','#FF1744','#F44336','#E53935','#D32F2F','#C62828','#B71C1C','#FF5252','#EF5350','#E91E63','#F06292','#FF4081','#AD1457','#D81B60','#C2185B','#EC407A','#F48FB1','#9C27B0','#7B1FA2','#8E24AA','#AB47BC','#673AB7','#5E35B1','#3F51B5','#3949AB','#2196F3','#1976D2','#1E88E5','#42A5F5','#00BCD4','#26C6DA','#0097A7','#80DEEA','#4CAF50','#43A047','#2E7D32','#66BB6A','#8BC34A','#9CCC65','#CDDC39','#AFB42B','#FFFFFF','#F5F5F5','#E0E0E0','#BDBDBD','#9E9E9E','#757575','#424242','#000000'] },
        { name: 'New-York Autumn', emoji: '🍂', colors: ['#8B3A3A','#A52A2A','#8B0000','#B22222','#D2691E','#FF8C00','#FF7F50','#F4A460','#CD853F','#C2A14A','#B8860B','#DAA520','#808000','#556B2F','#6B8E23','#8B4513','#5D4037','#4E342E','#3E2723','#2F4F4F','#37474F','#607D8B','#795548'] },
        { name: 'Brazilian Summer', emoji: '☀️', colors: ['#00FF7F','#1DE9B6','#00E676','#00C853','#2ECC71','#00A86B','#FFD700','#FFEB3B','#FFC107','#FDD835','#00BFFF','#1E90FF','#00B0FF','#18FFFF','#40E0D0','#FF1493','#FF69B4','#FF7F50','#FF5722','#F50057','#2962FF','#64DD17','#00C4FF'] },
        { name: 'Icelandic Winter', emoji: '❄️', colors: ['#E6F7FF','#E1F5FE','#B3E5FC','#81D4FA','#4FC3F7','#29B6F6','#03A9F4','#90A4AE','#B0BEC5','#CFD8DC','#ECEFF1','#FFFFFF','#F5F5F5','#BDBDBD','#9E9E9E','#78909C','#546E7A','#455A64','#37474F','#263238','#A7FFEB','#80DEEA','#4DD0E1'] },
        { name: 'Japanese Spring', emoji: '🌸', colors: ['#FFC0CB','#FFB7C5','#FFD1DC','#F8BBD0','#F48FB1','#E6E6FA','#D1C4E9','#B39DDB','#C1E1C1','#A5D6A7','#81C784','#DCEDC8','#FFF8DC','#FFF9C4','#FFF59D','#FFECB3','#87CEFA','#90CAF9','#64B5F6','#B3E5FC','#81D4FA','#80DEEA','#A7FFEB'] },
        { name: 'Amazon Rainforest', emoji: '🌳', colors: ['#013220','#145A32','#1E8449','#229954','#28B463','#2ECC71','#58D68D','#82E0AA','#A9DFBF','#196F3D','#27AE60','#52BE80','#239B56','#1D8348','#117A65','#0E6655','#73C6B6','#48C9B0','#16A085','#45B39D','#138D75','#117864','#0B5345'] },
        { name: 'Cosmos', emoji: '🌌', colors: ['#000000','#0B0C10','#1F2833','#263238','#37474F','#483D8B','#4B0082','#8A2BE2','#9370DB','#BA55D3','#DA70D6','#FF00FF','#FF69B4','#F8F8FF','#FFFFFF','#FFFACD','#E0FFFF','#B0E0E6','#40E0D0','#00BFFF','#1E90FF','#00008B','#191970'] }
      ];

      // ---- State ----
      let activePaletteIndex = 0;
      let n = 5;
      const GOLD = '#FFD700';
      let separatorPx = 6;
      let isBrushModeOn = true; // Default is paint mode (on)
      let hasPerformedInitialAutofill = false; // Flag for one-time autofill event

      // ---- Undo/Redo State ----
      const HISTORY_LIMIT = 5;
      let history = [];
      let future = [];

      // ---- Elements ----
      const board = document.getElementById('board');
      const btnPalette = document.getElementById('btnPalette');
      const btnGap = document.getElementById('btnGap');
      const btnUndo = document.getElementById('btnUndo');
      const btnRedo = document.getElementById('btnRedo');
      const btnRemix = document.getElementById('btnRemix');
      const btnBrushMode = document.getElementById('btnBrushMode');
      const root = document.documentElement;

      const tileClasses = 'tile aspect-square w-full outline-none focus-visible:ring-inset focus-visible:ring-4 focus-visible:ring-white/90';

      function palette() { return PALETTES[activePaletteIndex].colors; }

      // ---- History Management ----
      function getCurrentState() {
        const tiles = Array.from(board.querySelectorAll('.tile')).map(el => ({
            k: getIndex(el),
            isGold: !!el.dataset.goldOverlay
        }));
        return { n, activePaletteIndex, separatorPx, tiles };
      }

      function applyState(state) {
        activePaletteIndex = state.activePaletteIndex;
        separatorPx = state.separatorPx;
        updatePaletteHeader();
        applySeparator();

        if (n !== state.n) {
            n = state.n;
            buildBoard(n, false);
        }

        const tileElements = board.querySelectorAll('.tile');
        state.tiles.forEach((tileState, i) => {
            if (tileElements[i]) {
                const el = tileElements[i];
                if (tileState.isGold) {
                    applyGoldOverlay(el);
                } else {
                    delete el.dataset.goldOverlay;
                    setIndex(el, tileState.k);
                }
            }
        });
      }

      function pushHistory(state) {
        history.push(state);
        if (history.length > HISTORY_LIMIT) {
            history.shift();
        }
        future = [];
        updateUndoRedoButtons();
      }

      function performAction(actionFn) {
        const beforeState = getCurrentState();
        actionFn();
        const afterState = getCurrentState();
        if (JSON.stringify(beforeState) !== JSON.stringify(afterState)) {
            pushHistory({ before: beforeState, after: afterState });
            hasPerformedInitialAutofill = true;
        }
      }
      
      function undo() {
        if (history.length === 0) return;
        const lastAction = history.pop();
        future.push(lastAction);
        applyState(lastAction.before);
        clearAllHighlights();
        updateUndoRedoButtons();
      }

      function redo() {
        if (future.length === 0) return;
        const nextAction = future.pop();
        history.push(nextAction);
        applyState(nextAction.after);
        clearAllHighlights();
        updateUndoRedoButtons();
      }

      function updateUndoRedoButtons() {
        btnUndo.disabled = history.length === 0;
        btnRedo.disabled = future.length === 0;
      }

      // ---- Tiles & Highlights ----
      function createTile(idx = 0) {
        const d = document.createElement('div');
        d.className = tileClasses;
        d.setAttribute('role', 'gridcell');
        d.setAttribute('tabindex', '0');
        setIndex(d, idx);
        return d;
      }
      function setIndex(el, k) {
        el.dataset.k = String(k);
        if (!el.dataset.goldOverlay) {
          const m = palette().length;
          el.style.background = palette()[((k % m) + m) % m];
        }
      }
      function getIndex(el) { return parseInt(el.dataset.k || '0', 10); }
      function applyGoldOverlay(el) { el.style.background = GOLD; el.dataset.goldOverlay = '1'; }
      function clearGoldOverlay(el) {
        if (el.dataset.goldOverlay) {
          delete el.dataset.goldOverlay;
          const k = getIndex(el), m = palette().length;
          el.style.background = palette()[k % m];
        }
      }
      function clearAllHighlights() {
        board.querySelectorAll('.source-highlight, .target-highlight').forEach(el => {
            el.classList.remove('source-highlight', 'target-highlight');
        });
      }

      function isBoardAllGold() {
        const tiles = board.querySelectorAll('.tile');
        if (tiles.length === 0) return false;
        return Array.from(tiles).every(el => !!el.dataset.goldOverlay);
      }

      function buildBoard(size, applyGold = true) {
        root.style.setProperty('--grid-size', size);
        board.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (let i = 0; i < size * size; i++) {
            const tile = createTile(0);
            if(applyGold) applyGoldOverlay(tile);
            frag.appendChild(tile);
        }
        board.appendChild(frag);
        hasPerformedInitialAutofill = false; // Reset on new board build
      }
      
      function updatePaletteHeader() {
        const pal = PALETTES[activePaletteIndex];
        btnPalette.textContent = pal.emoji;
        const label = `Switch palette: ${pal.name} (${activePaletteIndex + 1}/${PALETTES.length})`;
        btnPalette.title = label;
        btnPalette.setAttribute('aria-label', label);
      }

      function applySeparator() {
        root.style.setProperty('--gap-px', separatorPx + 'px');
        const label = `Grid Separator`;
        btnGap.title = label;
        btnGap.setAttribute('aria-label', label);
      }

      // ---- Actions ----
      function cycleSeparator(forward = true) {
        const beforeState = getCurrentState();
        separatorPx = (separatorPx + (forward ? 1 : -1) + 9) % 9;
        applySeparator();
        const afterState = getCurrentState();
        if (JSON.stringify(beforeState) !== JSON.stringify(afterState)) {
             pushHistory({ before: beforeState, after: afterState });
        }
      }
      function randomizeAll() {
        performAction(() => {
            const m = palette().length;
            board.querySelectorAll('.tile').forEach(el => {
            clearGoldOverlay(el);
            setIndex(el, Math.floor(Math.random() * m));
            });
        });
      }
      function remixGrid() {
        performAction(() => {
            const tiles = Array.from(board.querySelectorAll('.tile'));
            let tileStates = tiles.map(el => ({
                k: getIndex(el),
                isGold: !!el.dataset.goldOverlay
            }));
            for (let i = tileStates.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [tileStates[i], tileStates[j]] = [tileStates[j], tileStates[i]];
            }
            tiles.forEach((el, i) => {
                const newState = tileStates[i];
                if (newState.isGold) {
                    applyGoldOverlay(el);
                } else {
                    clearGoldOverlay(el);
                    setIndex(el, newState.k);
                }
            });
            hasPerformedInitialAutofill = true;
        });
      }
      function resetToGoldAndDefaultPalette() {
        // This action resets the board, so it should not set the flag to true.
        const beforeState = getCurrentState();
        activePaletteIndex = 0;
        updatePaletteHeader();
        board.querySelectorAll('.tile').forEach(el => {
        setIndex(el, 0);
        applyGoldOverlay(el);
        });
        separatorPx = 6;
        applySeparator();
        hasPerformedInitialAutofill = false; // Reset the flag
        const afterState = getCurrentState();
        if (JSON.stringify(beforeState) !== JSON.stringify(afterState)) {
             pushHistory({ before: beforeState, after: afterState });
        }
      }
      function switchPalette(backwards = false) {
        const beforeState = getCurrentState();
        const len = PALETTES.length;
        const previousPaletteIndex = activePaletteIndex;
        const nextPaletteIndex = (activePaletteIndex + (backwards ? -1 : 1) + len) % len;
        
        const shouldAutoFill = 
            previousPaletteIndex === 0 &&
            !hasPerformedInitialAutofill;

        activePaletteIndex = nextPaletteIndex;
        updatePaletteHeader();

        if (shouldAutoFill) {
            const tiles = board.querySelectorAll('.tile');
            tiles.forEach((el, i) => {
                clearGoldOverlay(el);
                setIndex(el, 0); 
            });
            hasPerformedInitialAutofill = true;
        } else {
            const m = palette().length;
            board.querySelectorAll('.tile').forEach(el => {
                const k = getIndex(el);
                if (el.dataset.goldOverlay) {
                    delete el.dataset.goldOverlay;
                }
                el.style.background = palette()[((k % m) + m) % m];
            });
        }
        const afterState = getCurrentState();
        if (JSON.stringify(beforeState) !== JSON.stringify(afterState)) {
             pushHistory({ before: beforeState, after: afterState });
        }
      }
      function resizeGrid() {
        const input = prompt('Enter n (will build n×n and reset to gold):', String(n));
        if (input === null) return;
        const value = parseInt(String(input).trim(), 10);
        if (!Number.isFinite(value) || value <= 0) return;
        
        // This action resets the board, so it should not use the performAction wrapper.
        const beforeState = getCurrentState();
        n = value; 
        buildBoard(n, true);
        activePaletteIndex = 0;
        updatePaletteHeader();
        applySeparator();
        const afterState = getCurrentState();
        if (JSON.stringify(beforeState) !== JSON.stringify(afterState)) {
             pushHistory({ before: beforeState, after: afterState });
        }
      }
      function toggleBrushMode() {
        isBrushModeOn = !isBrushModeOn;
        btnBrushMode.classList.toggle('brush-on', isBrushModeOn);
        const newTitle = isBrushModeOn ? "Mode: Drag to Paint" : "Mode: Drag to Copy";
        btnBrushMode.title = newTitle;
        btnBrushMode.setAttribute('aria-label', newTitle);
        clearAllHighlights();
        if (pointerState.dragSource) pointerState.dragSource = null;
      }

      async function savePNG() {
        clearAllHighlights();
        board.querySelectorAll('.ring-inset, .ring-4, .ring-white').forEach(el => el.classList.remove('ring-inset', 'ring-4', 'ring-white', 'ring-white/90'));
        try {
          const boardCanvas = await html2canvas(board, { backgroundColor: null, scale: 2 });
          const padding = 25 * 2;
          const finalCanvas = document.createElement('canvas');
          finalCanvas.width = boardCanvas.width + padding;
          finalCanvas.height = boardCanvas.height + padding;
          const ctx = finalCanvas.getContext('2d');
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
          ctx.drawImage(boardCanvas, padding / 2, padding / 2);
          const link = document.createElement('a');
          link.download = 'board.png';
          link.href = finalCanvas.toDataURL('image/png');
          link.click();
        } catch (err) {
          console.error("Failed to save PNG:", err);
        }
      }

      // ---- Pointer interactions ----
      const HOLD_DELAY = 200, CYCLE_INTERVAL = 80, DRAG_THRESHOLD = 8;
      const pointerState = { id: null, downEl: null, downX: 0, downY: 0, longPressTimer: null, cyclingInterval: null, suppressClick: false, isDragging: false, dragSource: null, currentTarget: null, beforeState: null };

      function onPointerDown(e) {
        const el = e.target.closest('.tile'); if (!el) return;
        e.preventDefault();
        el.setPointerCapture(e.pointerId);

        Object.assign(pointerState, { 
            id: e.pointerId, 
            downEl: el, 
            suppressClick: false, 
            isDragging: false, 
            dragSource: null, 
            currentTarget: null, 
            cyclingInterval: null, 
            beforeState: getCurrentState() 
        });

        pointerState.longPressTimer = setTimeout(() => {
            if (pointerState.isDragging) return;
            pointerState.cyclingInterval = setInterval(() => {
                const beforeState = getCurrentState();
                clearGoldOverlay(el); 
                setIndex(el, getIndex(el) + 1);
                 const afterState = getCurrentState();
                if (JSON.stringify(beforeState) !== JSON.stringify(afterState)) {
                    hasPerformedInitialAutofill = true;
                }
            }, CYCLE_INTERVAL);
        }, HOLD_DELAY);

        if (isBrushModeOn) {
            pointerState.downX = e.clientX;
            pointerState.downY = e.clientY;
        } else { // Copy mode
            clearAllHighlights();
            el.classList.add('source-highlight');
            pointerState.dragSource = el;
        }
      }

      function onPointerMove(e) {
        if (pointerState.id !== e.pointerId) return;

        if (isBrushModeOn) {
            const dist = Math.hypot(e.clientX - pointerState.downX, e.clientY - pointerState.downY);
            if (!pointerState.isDragging && dist >= DRAG_THRESHOLD) {
                clearTimeout(pointerState.longPressTimer);
                clearInterval(pointerState.cyclingInterval);
                pointerState.longPressTimer = null;
                pointerState.cyclingInterval = null;
                pointerState.isDragging = true;
                pointerState.dragSource = pointerState.downEl;
                pointerState.suppressClick = true;
                clearGoldOverlay(pointerState.dragSource);
            }
            if (pointerState.isDragging) {
                const targetEl = document.elementFromPoint(e.clientX, e.clientY)?.closest('.tile');
                if (targetEl && pointerState.currentTarget !== targetEl) {
                    pointerState.currentTarget?.classList.remove('ring-4', 'ring-white');
                    pointerState.currentTarget = targetEl;
                    clearGoldOverlay(targetEl);
                    setIndex(targetEl, getIndex(pointerState.dragSource));
                    targetEl.classList.add('ring-4', 'ring-white');
                }
            }
        } else {
            if (!pointerState.dragSource) return;
             const dist = Math.hypot(e.clientX - pointerState.downEl.getBoundingClientRect().left, e.clientY - pointerState.downEl.getBoundingClientRect().top);
            if (dist > DRAG_THRESHOLD) { // Only start dragging after a small movement
                pointerState.isDragging = true;
                clearTimeout(pointerState.longPressTimer); // Cancel long press if dragging starts
            }
            
            if (pointerState.isDragging) {
                if (pointerState.currentTarget) pointerState.currentTarget.classList.remove('target-highlight');
                const targetEl = document.elementFromPoint(e.clientX, e.clientY)?.closest('.tile');
                if (targetEl && targetEl !== pointerState.dragSource) {
                    targetEl.classList.add('target-highlight');
                    pointerState.currentTarget = targetEl;
                } else {
                    pointerState.currentTarget = null;
                }
            }
        }
      }

      function onPointerUp(e) {
        clearTimeout(pointerState.longPressTimer);
        const wasCycling = !!pointerState.cyclingInterval;
        if (pointerState.cyclingInterval) {
            clearInterval(pointerState.cyclingInterval);
            pointerState.cyclingInterval = null;
            pointerState.suppressClick = true;
        }

        const beforeState = getCurrentState();

        if (wasCycling) {
            // Already handled in the interval itself
        } else if (pointerState.isDragging) {
            if (isBrushModeOn) {
                // Drag painting is a continuous action, check final state
            } else if (pointerState.currentTarget) {
                const sourceEl = pointerState.dragSource;
                const targetEl = pointerState.currentTarget;
                if (!!sourceEl.dataset.goldOverlay) {
                    applyGoldOverlay(targetEl);
                } else {
                    clearGoldOverlay(targetEl);
                    setIndex(targetEl, getIndex(sourceEl));
                }
            }
        } else if (!pointerState.suppressClick && e.target.closest('.tile')) {
            const tile = e.target.closest('.tile');
            clearGoldOverlay(tile);
            setIndex(tile, getIndex(tile) + 1);
        }

        const afterState = getCurrentState();
        if (JSON.stringify(beforeState) !== JSON.stringify(afterState)) {
             pushHistory({ before: beforeState, after: afterState });
             hasPerformedInitialAutofill = true;
        }
        
        clearAllHighlights();
        pointerState.currentTarget?.classList.remove('ring-4', 'ring-white', 'target-highlight');
        pointerState.id = null;
        pointerState.dragSource = null;
        pointerState.currentTarget = null;
      }
      
      board.addEventListener('pointerdown', onPointerDown);
      board.addEventListener('pointermove', onPointerMove);
      board.addEventListener('pointerup', onPointerUp);
      board.addEventListener('pointercancel', onPointerUp);

      // ---- Buttons ----
      document.getElementById('btnRandom').addEventListener('click', randomizeAll);
      btnRemix.addEventListener('click', remixGrid);
      document.getElementById('btnPalette').addEventListener('click', () => switchPalette());
      document.getElementById('btnResetGold').addEventListener('click', resetToGoldAndDefaultPalette);
      document.getElementById('btnResize').addEventListener('click', resizeGrid);
      document.getElementById('btnSave').addEventListener('click', savePNG);
      btnGap.addEventListener('click', (e) => cycleSeparator(!e.shiftKey));
      btnBrushMode.addEventListener('click', toggleBrushMode);
      btnUndo.addEventListener('click', undo);
      btnRedo.addEventListener('click', redo);

      // ---- Init ----
      buildBoard(n);
      updatePaletteHeader();
      applySeparator();
      updateUndoRedoButtons();
      // Set initial brush mode tooltip
      toggleBrushMode(); toggleBrushMode();
    })();
  </script>
</body>
</html>