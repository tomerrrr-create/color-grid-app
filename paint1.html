<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Grid App</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    /* Custom properties for dynamic styling controlled by JS */
    :root {
      --grid-size: 5;
      --gap-px: 6px;
      --tile-radius: 2px;
      /* New design tokens */
      --icon-size: 26px;
      --save-dot-size: 10px;
      --stroke: 3px;
      --gold: #FFD700;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(var(--grid-size), 1fr);
      gap: var(--gap-px);
      border-width: var(--gap-px);
      border-radius: 6px;
      -webkit-user-select: none; /* Prevents text selection in Safari (iOS) */
      user-select: none;          /* Prevents text selection in modern browsers */
    }
    .tile {
      border-radius: var(--tile-radius);
      transition: background-color 0.4s ease; /* Added smooth transition for color changes */
    }
    
    /* --- NEW CONTROL BUTTON STYLES --- */
    #controls {
      display: grid;
      grid-template-columns: repeat(4, 50px);
      grid-auto-rows: 50px;
      gap: 20px;
      justify-content: center; /* Center the grid container */
    }
    .ctrl {
      width: 50px;
      height: 50px;
      cursor: pointer;
      user-select: none;
      outline: none;
      background: transparent;
      border: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      position: relative;
      touch-action: manipulation; /* Prevents double-tap to zoom on iOS */
    }
    .ctrl:hover, .ctrl:focus-visible {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.25);
      border-radius: 8px;
    }
    .glyph {
      width: var(--icon-size);
      height: var(--icon-size);
      display: inline-block;
      position: relative;
    }
    .glyph-square-gold {
      background: #000;
      border: 2px solid var(--gold);
      box-sizing: border-box;
      border-radius: 2px;
    }
    .glyph-random {
      background: linear-gradient(90deg, #000 50%, #fff 50%);
      border-radius: 50%;
    }
    .palette {
      font-size: var(--icon-size);
      line-height: 1;
    }
    .glyph-hash { position: relative; }
    .glyph-hash::before, .glyph-hash::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      height: var(--stroke);
      background: #fff;
      border-radius: 2px;
    }
    .glyph-hash::before { top: 6px; }
    .glyph-hash::after { bottom: 6px; }
    .glyph-hash .v1, .glyph-hash .v2 {
      position: absolute;
      top: 0;
      bottom: 0;
      width: var(--stroke);
      background: #fff;
      border-radius: 2px;
    }
    .glyph-hash .v1 { left: 6px; }
    .glyph-hash .v2 { right: 6px; }
    .save { background: transparent; border: none; }
    .save::after {
      content: '';
      position: absolute;
      left: 50%;
      top: 50%;
      width: var(--save-dot-size);
      height: var(--save-dot-size);
      margin-left: calc(var(--save-dot-size) / -2);
      margin-top: calc(var(--save-dot-size) / -2);
      background: #fff;
      border-radius: 50%;
    }
    .glyph-gap {
      position: relative;
      width: var(--icon-size);
      height: var(--icon-size);
      display: inline-block;
    }
    .glyph-gap .bar {
      position: absolute;
      top: 0;
      bottom: 0;
      width: var(--stroke);
      background: #fff;
      border-radius: 2px;
    }
    .glyph-gap .b1 { left: 6px; }
    .glyph-gap .b2 { left: 50%; transform: translateX(-50%); }
    .glyph-gap .b3 { right: 6px; }

    /* Placement */
    #btnRandom { grid-row: 1; grid-column: 2; } 
    #btnPalette { grid-row: 1; grid-column: 3; } 
    #btnResetGold { grid-row: 2; grid-column: 1; }
    #btnGap { grid-row: 2; grid-column: 2; }
    #btnResize { grid-row: 2; grid-column: 3; }
    #btnSave { grid-row: 2; grid-column: 4; }

    @media (max-width: 480px) {
      .ctrl { width: 44px; height: 44px; }
      #controls {
        grid-template-columns: repeat(4, 44px);
        grid-auto-rows: 44px;
      }
    }
  </style>
</head>
<body class="bg-black text-[#eaeaea] font-sans">

  <div class="min-h-screen grid place-items-center p-6">
    <div class="w-full max-w-[720px] mx-auto" style="width: min(92vmin, 720px);">
      
      <div id="board" class="board bg-black border-black touch-none" aria-label="◊ú◊ï◊ó ◊¶◊ë◊¢◊ô◊ù" role="grid"></div>

      <div class="mt-11 flex justify-center">
        <div id="controls" aria-label="Control buttons">
            <button id="btnRandom" class="ctrl" aria-label="Randomizer" title="Randomizer">
                <span class="glyph glyph-random" aria-hidden="true"></span>
            </button>
            <button id="btnPalette" class="ctrl palette" aria-label="Switch palette" title="Switch palette"></button>
            
            <button id="btnResetGold" class="ctrl" aria-label="Reset to gold" title="Reset to gold">
                <span class="glyph glyph-square-gold" aria-hidden="true"></span>
            </button>
            <button id="btnResize" class="ctrl" aria-label="Resize (#)" title="Resize (#)">
                <span class="glyph glyph-hash" aria-hidden="true">
                    <span class="v1"></span><span class="v2"></span>
                </span>
            </button>
            <button id="btnGap" class="ctrl" aria-label="Tile separator thickness (0‚Äì8px)" title="Tile separator thickness (0‚Äì8px)">
                <span class="glyph glyph-gap" aria-hidden="true">
                    <span class="bar b1"></span><span class="bar b2"></span><span class="bar b3"></span>
                </span>
            </button>
            <button id="btnSave" class="ctrl save" aria-label="Save (PNG)" title="Save (PNG)"></button>
        </div>
      </div>

    </div>
  </div>

  <script>
    // Tailwind CSS Custom JIT Classes (for dynamic classes)
    tailwind.config = {
      theme: {
        extend: {
          // No extensions needed for this app
        }
      }
    }

    // Base classes used by JS
    const tileClasses = 'tile aspect-square w-full outline-none focus-visible:ring-inset focus-visible:ring-4 focus-visible:ring-white/90';
    // sr-only class is no longer used by controls but might be useful elsewhere
    const srOnlyClasses = 'sr-only absolute w-px h-px p-0 -m-px overflow-hidden whitespace-nowrap border-0';
    
    // NOTE: The dynamic button class assignment was removed as it's now handled by CSS.

    (function() {
      const PALETTES = [
        { name: 'Default', emoji: 'üåì', colors: ['#FFD700','#FFC107','#FFEE58','#FDD835','#FBC02D','#FFE082','#FFCA28','#FFF176','#FF8C00','#FF9800','#FB8C00','#FFA726','#FF7043','#FF5722','#F4511E','#F57C00','#FF1744','#F44336','#E53935','#D32F2F','#C62828','#B71C1C','#FF5252','#EF5350','#E91E63','#F06292','#FF4081','#AD1457','#D81B60','#C2185B','#EC407A','#F48FB1','#9C27B0','#7B1FA2','#8E24AA','#AB47BC','#673AB7','#5E35B1','#3F51B5','#3949AB','#2196F3','#1976D2','#1E88E5','#42A5F5','#00BCD4','#26C6DA','#0097A7','#80DEEA','#4CAF50','#43A047','#2E7D32','#66BB6A','#8BC34A','#9CCC65','#CDDC39','#AFB42B','#FFFFFF','#F5F5F5','#E0E0E0','#BDBDBD','#9E9E9E','#757575','#424242','#000000'] },
        { name: 'New-York Autumn', emoji: 'üçÇ', colors: ['#8B3A3A','#A52A2A','#8B0000','#B22222','#D2691E','#FF8C00','#FF7F50','#F4A460','#CD853F','#C2A14A','#B8860B','#DAA520','#808000','#556B2F','#6B8E23','#8B4513','#5D4037','#4E342E','#3E2723','#2F4F4F','#37474F','#607D8B','#795548'] },
        { name: 'Brazilian Summer', emoji: '‚òÄÔ∏è', colors: ['#00FF7F','#1DE9B6','#00E676','#00C853','#2ECC71','#00A86B','#FFD700','#FFEB3B','#FFC107','#FDD835','#00BFFF','#1E90FF','#00B0FF','#18FFFF','#40E0D0','#FF1493','#FF69B4','#FF7F50','#FF5722','#F50057','#2962FF','#64DD17','#00C4FF'] },
        { name: 'Icelandic Winter', emoji: '‚ùÑÔ∏è', colors: ['#E6F7FF','#E1F5FE','#B3E5FC','#81D4FA','#4FC3F7','#29B6F6','#03A9F4','#90A4AE','#B0BEC5','#CFD8DC','#ECEFF1','#FFFFFF','#F5F5F5','#BDBDBD','#9E9E9E','#78909C','#546E7A','#455A64','#37474F','#263238','#A7FFEB','#80DEEA','#4DD0E1'] },
        { name: 'Japanese Spring', emoji: 'üå∏', colors: ['#FFC0CB','#FFB7C5','#FFD1DC','#F8BBD0','#F48FB1','#E6E6FA','#D1C4E9','#B39DDB','#C1E1C1','#A5D6A7','#81C784','#DCEDC8','#FFF8DC','#FFF9C4','#FFF59D','#FFECB3','#87CEFA','#90CAF9','#64B5F6','#B3E5FC','#81D4FA','#80DEEA','#A7FFEB'] },
        { name: 'Amazon Rainforest', emoji: 'üå≥', colors: ['#013220','#145A32','#1E8449','#229954','#28B463','#2ECC71','#58D68D','#82E0AA','#A9DFBF','#196F3D','#27AE60','#52BE80','#239B56','#1D8348','#117A65','#0E6655','#73C6B6','#48C9B0','#16A085','#45B39D','#138D75','#117864','#0B5345'] },
        { name: 'Cosmos', emoji: 'üåå', colors: ['#000000','#0B0C10','#1F2833','#263238','#37474F','#483D8B','#4B0082','#8A2BE2','#9370DB','#BA55D3','#DA70D6','#FF00FF','#FF69B4','#F8F8FF','#FFFFFF','#FFFACD','#E0FFFF','#B0E0E6','#40E0D0','#00BFFF','#1E90FF','#00008B','#191970'] }
      ];

      // ---- State ----
      let activePaletteIndex = 0;
      let n = 5;
      const GOLD = '#FFD700';
      let separatorPx = 6;

      // ---- Elements ----
      const board = document.getElementById('board');
      const btnPalette = document.getElementById('btnPalette');
      const btnGap = document.getElementById('btnGap');
      const root = document.documentElement;

      function palette() { return PALETTES[activePaletteIndex].colors; }

      // ---- Tiles ----
      let initialBuildGoldOverlay = true;
      function createTile(idx = 0) {
        const d = document.createElement('div');
        d.className = tileClasses;
        d.setAttribute('role', 'gridcell');
        d.setAttribute('tabindex', '0');
        setIndex(d, idx);
        if (initialBuildGoldOverlay) applyGoldOverlay(d);
        return d;
      }
      function setIndex(el, k) {
        el.dataset.k = String(k);
        if (!el.dataset.goldOverlay) {
          const m = palette().length;
          el.style.background = palette()[((k % m) + m) % m];
        }
      }
      function getIndex(el) { return parseInt(el.dataset.k || '0', 10); }
      function applyGoldOverlay(el) { el.style.background = GOLD; el.dataset.goldOverlay = '1'; }
      function clearGoldOverlay(el) {
        if (el.dataset.goldOverlay) {
          delete el.dataset.goldOverlay;
          const k = getIndex(el), m = palette().length;
          el.style.background = palette()[k % m];
        }
      }

      function buildBoard(size) {
        root.style.setProperty('--grid-size', size);
        board.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (let i = 0; i < size * size; i++) frag.appendChild(createTile(0));
        board.appendChild(frag);
      }
      
      function updatePaletteHeader() {
        const pal = PALETTES[activePaletteIndex];
        btnPalette.textContent = pal.emoji;
        const label = `Switch palette: ${pal.name} (${activePaletteIndex + 1}/${PALETTES.length})`;
        btnPalette.title = label;
        btnPalette.setAttribute('aria-label', label);
      }

      function applySeparator() {
        root.style.setProperty('--gap-px', separatorPx + 'px');
        const label = `Tile separator thickness (${separatorPx}px)`;
        btnGap.title = label;
        btnGap.setAttribute('aria-label', label);
      }
      function cycleSeparator(forward = true) {
        separatorPx = (separatorPx + (forward ? 1 : -1) + 9) % 9;
        applySeparator();
      }

      // ---- Actions ----
      function cycleTile(el, step = 1) { clearGoldOverlay(el); setIndex(el, getIndex(el) + step); }
      function randomizeAll() {
        const m = palette().length;
        board.querySelectorAll('.tile').forEach(el => {
          clearGoldOverlay(el);
          setIndex(el, Math.floor(Math.random() * m));
        });
      }
      function resetToGoldAndDefaultPalette() {
        activePaletteIndex = 0;
        updatePaletteHeader();
        board.querySelectorAll('.tile').forEach(el => {
          setIndex(el, 0);
          applyGoldOverlay(el);
        });
        separatorPx = 6;
        applySeparator();
      }
      function switchPalette(backwards = false) {
        const len = PALETTES.length;
        activePaletteIndex = (activePaletteIndex + (backwards ? -1 : 1) + len) % len;
        updatePaletteHeader();
        const m = palette().length;
        board.querySelectorAll('.tile').forEach(el => {
          if (!el.dataset.goldOverlay) {
            const k = getIndex(el);
            el.style.background = palette()[((k % m) + m) % m];
          }
        });
      }
      function resizeGrid() {
        const input = prompt('◊î◊õ◊†◊° n (◊ô◊ë◊†◊î n√ón ◊ï◊ô◊ê◊§◊° ◊ú◊ñ◊î◊ë):', String(n));
        if (input === null) return;
        const value = parseInt(String(input).trim(), 10);
        if (!Number.isFinite(value) || value <= 0) return;
        n = value; initialBuildGoldOverlay = true; buildBoard(n);
        applySeparator();
      }

      async function savePNG() {
        // Remove any focus rings before capture
        board.querySelectorAll('.ring-inset, .ring-4, .ring-white').forEach(el => el.classList.remove('ring-inset', 'ring-4', 'ring-white', 'ring-white/90'));

        try {
          // 1. Capture the board itself
          const boardCanvas = await html2canvas(board, { 
              backgroundColor: null, // Transparent background for the board capture
              scale: 2 
          });

          // 2. Create a new, larger canvas for the final image
          const padding = 25 * 2; // Padding is based on scale, so multiply by scale factor
          const finalCanvas = document.createElement('canvas');
          finalCanvas.width = boardCanvas.width + padding;
          finalCanvas.height = boardCanvas.height + padding;
          const ctx = finalCanvas.getContext('2d');

          // 3. Fill the new canvas with black
          ctx.fillStyle = '#000';
          ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);

          // 4. Draw the captured board image onto the center of the new canvas
          ctx.drawImage(boardCanvas, padding / 2, padding / 2);
          
          // 5. Trigger download
          const link = document.createElement('a');
          link.download = 'board.png';
          link.href = finalCanvas.toDataURL('image/png');
          link.click();

        } catch (err) {
          console.error("Failed to save PNG:", err);
        }
      }

      // ---- Pointer interactions ----
      const HOLD_DELAY = 200, CYCLE_INTERVAL = 80, DRAG_THRESHOLD = 8;
      const pointerState = { id: null, downEl: null, downX: 0, downY: 0, longPressTimer: null, cyclingInterval: null, suppressClick: false, isDragging: false, dragSource: null, currentTarget: null };

      function onPointerDown(e) {
        const el = e.target.closest('.tile'); if (!el) return;
        e.preventDefault();
        el.setPointerCapture(e.pointerId);
        Object.assign(pointerState, { id: e.pointerId, downEl: el, downX: e.clientX, downY: e.clientY, suppressClick: false, isDragging: false, dragSource: null, currentTarget: null, cyclingInterval: null });
        
        pointerState.longPressTimer = setTimeout(() => {
          if (pointerState.isDragging) return;
          pointerState.cyclingInterval = setInterval(() => cycleTile(el, 1), CYCLE_INTERVAL);
        }, HOLD_DELAY);
      }

      function onPointerMove(e) {
        if (pointerState.id !== e.pointerId) return;
        const dist = Math.hypot(e.clientX - pointerState.downX, e.clientY - pointerState.downY);
        
        if (!pointerState.isDragging && dist >= DRAG_THRESHOLD) {
          clearTimeout(pointerState.longPressTimer);
          clearInterval(pointerState.cyclingInterval);
          pointerState.longPressTimer = null;
          pointerState.cyclingInterval = null;
          pointerState.isDragging = true;
          pointerState.dragSource = pointerState.downEl;
          pointerState.suppressClick = true;

          // MODIFICATION: "Pick up" the color when drag starts by clearing any gold overlay.
          // This ensures we are dragging the underlying color, not the gold itself.
          clearGoldOverlay(pointerState.dragSource);
        }

        if (pointerState.isDragging) {
          const targetEl = document.elementFromPoint(e.clientX, e.clientY)?.closest('.tile');
          if (targetEl && pointerState.currentTarget !== targetEl) {
            pointerState.currentTarget?.classList.remove('ring-4', 'ring-white');
            pointerState.currentTarget = targetEl;
            
            // MODIFICATION: Paint immediately on hover ("drag-to-paint" effect).
            clearGoldOverlay(targetEl);
            setIndex(targetEl, getIndex(pointerState.dragSource));
            
            targetEl.classList.add('ring-4', 'ring-white');
          }
        }
      }

      function onPointerUp(e) {
        clearTimeout(pointerState.longPressTimer);
        if (pointerState.cyclingInterval) {
          clearInterval(pointerState.cyclingInterval);
          pointerState.cyclingInterval = null;
          pointerState.suppressClick = true;
        }

        if (pointerState.isDragging) {
          // MODIFICATION: The painting is already done in onPointerMove.
          // We just need to clean up the visual ring from the last hovered tile.
          pointerState.currentTarget?.classList.remove('ring-4', 'ring-white');
        } else if (!pointerState.suppressClick && e.target.closest('.tile')) {
          cycleTile(e.target.closest('.tile'), 1);
        }
        
        pointerState.id = null;
      }
      
      board.addEventListener('pointerdown', onPointerDown);
      board.addEventListener('pointermove', onPointerMove);
      board.addEventListener('pointerup', onPointerUp);
      board.addEventListener('pointercancel', onPointerUp); // Treat cancel as up

      // ---- Buttons ----
      document.getElementById('btnRandom').addEventListener('click', randomizeAll);
      document.getElementById('btnPalette').addEventListener('click', () => switchPalette());
      document.getElementById('btnResetGold').addEventListener('click', resetToGoldAndDefaultPalette);
      document.getElementById('btnResize').addEventListener('click', resizeGrid);
      document.getElementById('btnSave').addEventListener('click', savePNG);
      btnGap.addEventListener('click', (e) => cycleSeparator(!e.shiftKey));

      // ---- Init ----
      buildBoard(n);
      updatePaletteHeader();
      applySeparator();
    })();
  </script>
</body>
</html>