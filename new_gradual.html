<!DOCTYPE html>
<html lang="he" dir="ltr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Color Grid App</title>

  <meta property="og:type" content="website">
  <meta property="og:url" content="https://tomerrrr-create.github.io/color-grid-app/">
  <meta property="og:title" content="Follow Your Intuition">
  <meta property="og:description" content="----------------">
  <meta property="og:image" content="https://raw.githubusercontent.com/tomerrrr-create/color-grid-app/refs/heads/main/og.PNG">
  <meta property="og:locale" content="en_US" />

  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://tomerrrr-create.github.io/color-grid-app/">
  <meta name="twitter:title" content="Follow Your Intuition">
  <meta name="twitter:description" content="----------------">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/tomerrrr-create/color-grid-app/refs/heads/main/og.PNG">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    /* Custom properties for dynamic styling controlled by JS */
    :root {
      --grid-size: 8;
      --gap-px: 3px;
      --tile-radius: 2px;
      --icon-size: 26px;
      --side-icon-size: 20px; /* MODIFIED: Smaller side icons */
      --save-dot-size: 10px;
      --reset-dot-size: 7px;  /* MODIFIED: Smaller reset dot */
      --stroke: 3px;
      --gold: #FFD700; 
      --glow-color: var(--gold);
    }
    
    /* --- MOBILE STABILITY FIXES --- */
    html, body {
      height: 100%;
      overflow: hidden;
      position: fixed;
      width: 100%;
    }
    #appContainer {
      touch-action: none;
    }
    
    body {
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none; /* IE 10+ */
      user-select: none; /* Standard syntax */
    }
    .board {
      display: grid;
      grid-template-columns: repeat(var(--grid-size), 1fr);
      gap: var(--gap-px);
      border-width: var(--gap-px);
      border-radius: 6px;
      transition: gap 0.3s ease-in-out, box-shadow 0.3s ease-in-out;
      position: relative;
    }
    .tile {
      border-radius: var(--tile-radius);
      transition: background-color 0.4s ease, box-shadow 0.2s ease, border-radius 0.6s ease-in-out;
    }
    
    /* --- CONTROL BUTTON STYLES --- */
    #controls {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      column-gap: 12px;
      row-gap: 8px;
    }
    .side-controls {
      display: grid;
      grid-template-columns: 50px;
      grid-template-rows: repeat(4, 50px);
      row-gap: 8px; /* Match main controls */
    }

    #controlsContainer {
        position: relative;
    }
    
    #controlsContainer.controls-hidden {
        opacity: 0;
        pointer-events: none;
    }

    .ctrl {
      width: 50px;
      height: 50px;
      cursor: pointer;
      outline: none;
      background: transparent;
      border: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      position: relative;
      /* removed touch-action: manipulation to inherit 'none' from body */
      transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out, background-color 0.3s ease-in-out, visibility 0.4s;
    }
    .ctrl * {
      pointer-events: none;
    }
    .ctrl:focus-visible {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.25);
      border-radius: 8px;
    }
    @media (hover: hover) {
      .ctrl:hover {
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.25);
        border-radius: 8px;
      }
    }
    .ctrl:disabled {
        opacity: 0.3 !important;
        cursor: not-allowed !important;
        box-shadow: none;
        pointer-events: none !important;
    }
    .glyph {
      width: var(--icon-size);
      height: var(--icon-size);
      display: inline-block;
      position: relative;
    }
    .ctrl svg {
        width: var(--icon-size);
        height: var(--icon-size);
    }
    #btnResizeUp svg, #btnResizeDown svg, #btnShowBreatheMenu svg, #btnGap svg, #btnBrushMode svg {
        width: var(--side-icon-size);
        height: var(--side-icon-size);
    }
    .glyph-square-gold {
      background: #000;
      border: 2px solid var(--gold);
      box-sizing: border-box;
      border-radius: 2px;
    }
    .glyph-square-white {
      background: #000;
      border: 2px solid #fff;
      box-sizing: border-box;
      border-radius: 2px;
    }
    .glyph-random {
      background: linear-gradient(90deg, #000 50%, #fff 50%);
      border-radius: 50%;
    }
    .glyph-invert {
      background: linear-gradient(90deg, #fff 50%, #000 50%);
      border-radius: 50%;
    }
    .palette {
      font-size: var(--icon-size);
      line-height: 1;
    }
    
    .glyph-save, .glyph-reset, .glyph-special-reset, .glyph-dark {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
    }
    .glyph-save::after {
      content: '';
      width: var(--save-dot-size);
      height: var(--save-dot-size);
      border-radius: 50%;
      background: #FFFFFF;
    }
    
    .glyph-reset::after {
      content: '';
      width: var(--reset-dot-size);
      height: var(--reset-dot-size);
      background: #fff;
      border-radius: 50%;
    }

    .glyph-dark::after {
      content: '';
      width: var(--reset-dot-size);
      height: var(--reset-dot-size);
      background: #424242; /* Dark Gray */
      border-radius: 50%;
    }

    .glyph-special-reset {
        width: 8px;
        height: 8px;
        background-color: var(--gold);
        border-radius: 50%;
    }

    #btnBrushMode svg path {
        transition: fill 0.2s ease-in-out;
    }
    #btnBrushMode.brush-on svg path {
        fill: #fff;
    }
    .tile.source-highlight {
        box-shadow: 0 0 0 4px var(--gold) inset;
    }
    .tile.target-highlight {
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8) inset;
    }
    .app-shell {
      width: min(85vmin, 720px);
    }
    #boardOverlay {
        transition: opacity 350ms ease-in-out;
    }
    @keyframes glow-effect {
      0%, 100% {
        filter: drop-shadow(0 0 0px var(--gold));
        transform: scale(1);
      }
      50% {
        filter: drop-shadow(0 0 8px var(--gold));
        transform: scale(1.1);
      }
    }
    .glow-animation .glyph-random, .glow-animation .glyph-invert, .glow-animation.palette, .glow-animation svg, .glow-animation .glyph-special-reset {
      animation: glow-effect 2s ease-in-out infinite;
    }
    .glow-animation-separator svg {
      animation: glow-effect 2s ease-in-out infinite;
    }
    #saveModal, #breatheModal, #colorPickerModal, #helpModal, #resizeModal {
      transition: opacity 300ms ease-in-out, visibility 300ms ease-in-out;
      visibility: hidden;
      opacity: 0;
    }
    #saveModal.modal-visible, #breatheModal.modal-visible, #colorPickerModal.modal-visible, #helpModal.modal-visible, #resizeModal.modal-visible {
      visibility: visible;
      opacity: 1;
    }

    #longPressOverlay {
      background-color: rgba(0, 0, 0, 0.95);
      opacity: 0;
      transition: opacity 200ms ease-out;
    }
    #longPressDisplay {
      opacity: 0;
      transform: scale(0.95);
      transition: opacity 200ms ease-out 50ms, transform 200ms ease-out 50ms;
    }
    #longPressOverlay.visible, #longPressDisplay.visible {
      opacity: 1;
    }
    #longPressDisplay.visible {
        transform: scale(1);
    }

    @media (max-width: 480px) {
      .ctrl { width: 44px; height: 44px; }
      .side-controls {
        grid-template-columns: 44px;
        grid-template-rows: repeat(4, 44px);
      }
       #controls {
        grid-template-columns: repeat(3, 44px);
        grid-template-rows: repeat(3, 44px);
      }
      #controlsContainer {
        justify-content: space-between;
      }
    }
    .board.no-gap-fix .tile {
      transform: scale(1.02);
    }
    
    #btnSymmetry .part {
        transition: stroke 0.3s ease-in-out;
    }

    @keyframes breathe {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(0.4); }
    }
    .breathing-tile {
      animation: breathe 4s infinite;
    }

    #breatheExitContainer {
      position: absolute;
      bottom: 82px; 
      left: 0;
      right: 0;
      height: 50px;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      z-index: 10;
    }

    #btnExitBreathe {
      width: 50px;
      height: 50px;
      background-color: black;
      border: 2px solid #383838;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1.5s ease-in-out;
    }

    #btnExitBreathe.visible {
      opacity: 0.7;
      pointer-events: auto;
    }

    #btnExitBreathe::after {
      content: '';
      width: 6px;
      height: 6px;
      background-color: #4a4a4a;
      border-radius: 50%;
    }

    #splashScreen {
        transition: opacity 2s linear;
    }
    #splashText {
      letter-spacing: 1.5px;
      word-spacing: 6px;
    }
    .splash-tutorial-focus {
        z-index: 1001;
        position: relative;
    }

    @keyframes fadeInText {
      0%   { color: black; opacity: 0; }
      100% { color: var(--gold); opacity: 1; }
    }
    @keyframes fadeOutText {
      from { color: var(--gold); opacity: 1; }
      to { color: black; opacity: 0; }
    }

    .breathe-option-btn {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        background-color: rgba(255, 255, 255, 0.05);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 12px;
        padding: 16px;
        width: 120px;
        height: 120px;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out, transform 0.2s ease-out;
    }
    .breathe-option-btn:hover {
        background-color: rgba(255, 255, 255, 0.1);
        transform: translateY(-4px);
    }
    
    .save-tile {
      width: 90px;
      height: 90px;
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border: none;
      transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
    }
    .save-tile:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    }
    .save-tile svg {
      width: 40px;
      height: 40px;
    }

    #colorPickerModal .color-swatch {
        position: relative;
        width: 100%;
        padding-top: 100%;
        border-radius: 8px;
        cursor: pointer;
        transition: transform 0.2s ease-out, box-shadow 0.2s ease-out;
        border: 2px solid transparent;
        box-sizing: border-box;
    }
    #colorPickerModal .color-swatch:hover {
        transform: scale(1.1);
    }
    #colorPickerPagination .pagination-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background-color: #4a4a4a;
        margin: 0 4px;
        cursor: pointer;
        transition: background-color 0.2s ease-in-out;
    }
    #colorPickerPagination .pagination-dot.active {
        background-color: #eaeaea;
    }
    #colorPickerModal .color-swatch-inner {
        position: absolute;
        inset: 0;
        border-radius: inherit;
    }

    #helpModalContent::-webkit-scrollbar { width: 6px; }
    #helpModalContent::-webkit-scrollbar-track { background: #2d2d2d; border-radius: 3px; }
    #helpModalContent::-webkit-scrollbar-thumb { background: #555; border-radius: 3px; }
    #helpModalContent::-webkit-scrollbar-thumb:hover { background: #777; }
    .help-item-icon-wrapper {
        width: 50px;
        height: 50px;
        flex-shrink: 0;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    .help-item-icon-wrapper .glyph,
    .help-item-icon-wrapper svg {
      width: var(--icon-size);
      height: var(--icon-size);
    }
    .help-item-icon-wrapper .palette { font-size: var(--icon-size); }
    .help-item-icon-wrapper #btnResizeUp svg, 
    .help-item-icon-wrapper #btnResizeDown svg, 
    .help-item-icon-wrapper #btnShowBreatheMenu svg, 
    .help-item-icon-wrapper #btnGap svg,
    .help-item-icon-wrapper #btnBrushMode svg {
        width: var(--side-icon-size);
        height: var(--side-icon-size);
    }
    
    #resizeInput:focus {
        border-color: var(--gold);
        box-shadow: 0 0 0 2px rgba(255, 215, 0, 0.4);
        outline: none;
    }
    #btnConfirmResize {
        background-color: var(--gold);
        transition: background-color 0.2s;
    }
    #btnConfirmResize:hover {
        background-color: #e6c200;
    }
    .help-category-title {
        font-size: 1.1rem;
        font-weight: bold;
        color: var(--gold);
        margin-top: 1rem;
        margin-bottom: 0.5rem;
        border-bottom: 1px solid #444;
        padding-bottom: 0.25rem;
    }
    .help-intro-text {
        font-style: italic;
        color: #ccc;
        margin-bottom: 1rem;
        text-align: center;
    }

    /* --- Glowing Border for Selected Color --- */
    .board.glowing-border {
      animation: glow-border 3s infinite;
    }
    .board.glowing-border-rainbow {
       animation: glow-border-rainbow 5s infinite;
    }
    
    @keyframes glow-border {
      50% {
        box-shadow: 0 0 12px 4px var(--glow-color);
      }
    }
    @keyframes glow-border-rainbow {
      0% { box-shadow: 0 0 12px 4px #ff0000; }
      16% { box-shadow: 0 0 12px 4px #ff7f00; }
      33% { box-shadow: 0 0 12px 4px #ffff00; }
      50% { box-shadow: 0 0 12px 4px #00ff00; }
      66% { box-shadow: 0 0 12px 4px #0000ff; }
      83% { box-shadow: 0 0 12px 4px #4b0082; }
      100% { box-shadow: 0 0 12px 4px #8f00ff; }
    }

    .rtl-mode {
      direction: rtl;
    }

    /* --- Onboarding Styles --- */
    .ctrl.onboarding-hidden {
      visibility: hidden;
      opacity: 0;
      transform: scale(0.8);
      pointer-events: none;
    }

    .ctrl.onboarding-visible {
        visibility: visible;
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
    }
    
    #btnResetOnboarding {
        margin: 1.5rem auto 0;
        display: block;
        width: 44px;
        height: 50px;
        background-color: var(--gold);
        border: none;
        cursor: pointer;
        clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
        transition: transform 0.2s ease-out, background-color 0.2s ease-out;
    }
    #btnResetOnboarding:hover {
        transform: scale(1.1);
        background-color: #e6c200;
    }
  </style>
</head>
<body class="bg-black text-[#eaeaea] font-sans">

  <div id="splashScreen" class="fixed inset-0 bg-black flex items-center justify-center z-[1000]">
    <h1 id="splashText" class="text-3xl" style="color: black; opacity: 0;"></h1>
  </div>

  <div id="appContainer" class="min-h-screen flex flex-col items-center justify-start p-6 pt-10 sm:pt-12">
    <div class="w-full max-w-[720px] mx-auto app-shell">
      
      <div class="relative">
        <div id="board" class="board bg-black border-black" aria-label="Color Grid" role="grid">
            </div>
        <div id="boardOverlay" class="absolute inset-0 bg-black opacity-0 pointer-events-none"></div>
        
        <div id="longPressOverlay" class="absolute inset-0 pointer-events-none"></div>
        <div id="longPressDisplay" class="absolute inset-0 flex flex-col items-center justify-center gap-8 sm:gap-12 pointer-events-none">
        </div>
      </div>

      <div id="controlsContainer" class="mt-11 flex justify-between items-start">
        
        <div class="side-controls">
            <button id="btnShowBreatheMenu" class="ctrl">
                <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M3 12 C3 9 9 9 12 12 S 15 15 21 12"></path>
                </svg>
            </button>
             <button id="btnDark" class="ctrl">
                <span class="glyph-dark"></span>
            </button>
            <button id="btnSave" class="ctrl">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M12 4v12"></path>
                    <path d="m16 12-4 4-4-4"></path>
                </svg>
            </button>
            <button id="btnTutorial" class="ctrl">
                <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
                  <text x="12" y="17.5" text-anchor="middle" style="font-family: Arial, sans-serif; font-weight: bold; font-size: 11px;">WTF</text>
                </svg>
            </button>
        </div>
        
        <div id="controls" aria-label="Control buttons">
            <button id="btnInvert" class="ctrl">
                <span class="glyph glyph-invert" aria-hidden="true"></span>
            </button>
            <button id="btnPalette" class="ctrl palette"></button>
            <button id="btnRandom" class="ctrl">
                <span class="glyph glyph-random" aria-hidden="true"></span>
            </button>
            
            <button id="btnColorPicker" class="ctrl">
                <svg viewBox="0 0 24 24" stroke-width="2">
                    <circle cx="12" cy="12" r="8"></circle>
                </svg>
            </button>
            <button id="btnSymmetry" class="ctrl">
                <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" aria-hidden="true">
                    <rect x="3" y="3" width="18" height="18" fill="none" stroke="#424242" />
                    <path class="part top" d="M3 3 H 21" stroke="transparent" />
                    <path class="part bottom" d="M3 21 H 21" stroke="transparent" />
                    <path class="part left" d="M3 3 V 21" stroke="transparent" />
                    <path class="part right" d="M21 3 V 21" stroke="transparent" />
                </svg>
            </button>
            <button id="btnBrushMode" class="ctrl">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 2 L2 22 L22 22 Z" stroke="#fff" stroke-width="2" fill="#000" />
                </svg>
            </button>

            <button id="btnRedo" class="ctrl">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M21 10v4c0 1.1-.9 2-2 2h-7"/>
                    <path d="M21 10l-4-4-4 4"/>
                </svg>
            </button>
            <button id="btnSpecialReset" class="ctrl">
                <span class="glyph-special-reset"></span>
            </button>
            <button id="btnUndo" class="ctrl">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M3 10v4c0 1.1.9 2 2 2h7"/>
                    <path d="M3 10l4-4 4 4"/>
                </svg>
            </button>
        </div>

        <div class="side-controls">
            <button id="btnResizeUp" class="ctrl">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M12 6v12m6-6H6" />
                </svg>
            </button>
            <button id="btnResizeDown" class="ctrl">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M18 12H6" />
                </svg>
            </button>
            <button id="btnGap" class="ctrl">
                <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" aria-hidden="true">
                  <path d="M8 3v18M16 3v18M3 8h18M3 16h18"/>
                </svg>
            </button>
            <button id="btnResetBoard" class="ctrl">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="6" r="3"></circle>
                    <line x1="12" y1="9" x2="12" y2="15"></line>
                    <line x1="12" y1="11" x2="7" y2="8"></line>
                    <line x1="12" y1="11" x2="17" y2="8"></line>
                    <line x1="12" y1="15" x2="9" y2="21"></line>
                    <line x1="12" y1="15" x2="15" y2="21"></line>
                </svg>
            </button>
        </div>
      </div>
      
      <div id="breatheExitContainer">
        <button id="btnExitBreathe"></button>
      </div>

    </div>
  </div>

  <div id="saveModal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50">
    <div class="bg-[#1c1c1c] rounded-lg p-6 max-w-sm w-full text-center relative">
      <button id="btnModalClose" class="absolute top-3 right-3 text-gray-400 hover:text-white">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
      </button>
      <img id="imagePreview" class="rounded-md mb-4 border-2 border-gray-600 max-w-full h-auto" src="" alt="Image Preview">
      <div class="mb-6 text-right">
        <label id="fileNameLabel" for="fileNameInput" class="block text-sm font-medium text-gray-300 mb-1"></label>
        <input type="text" id="fileNameInput" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5">
      </div>
      
      <div class="flex justify-center gap-4">
        <button id="btnSaveImage" class="save-tile" style="background-color: #D2691E;">
            <svg viewBox="0 0 24 24" stroke="black" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
                <circle cx="8.5" cy="8.5" r="1.5"></circle>
                <polyline points="21 15 16 10 5 21"></polyline>
            </svg>
        </button>
        <button id="btnSaveProjectIdea" class="save-tile" style="background-color: #CD853F;">
            <svg viewBox="0 0 24 24" stroke="black" stroke-width="2.5" fill="none" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 18h6M10 22h4M12 2a5 5 0 0 0-5 5c0 2.4 1.2 4.5 3 5.7V17a1 1 0 0 0 1 1h2a1 1 0 0 0 1-1v-4.3c1.8-1.2 3-3.3 3-5.7a5 5 0 0 0-5-5Z"></path>
            </svg>
        </button>
        <button id="btnLoadProjectIdea" class="save-tile" style="background-color: #8B3A3A;">
            <svg viewBox="0 0 24 24" fill="#B22222" stroke="black" stroke-width="2.5">
                <circle cx="12" cy="12" r="10"></circle>
            </svg>
        </button>
      </div>

      <input type="file" id="projectFileInput" accept=".json, .cga" style="display: none;" />
    </div>
  </div>

  <div id="breatheModal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50">
    <div class="bg-[#1c1c1c] rounded-lg p-6 max-w-xs w-full text-center relative">
        <button id="btnBreatheModalClose" class="absolute top-3 right-3 text-gray-400 hover:text-white">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
        </button>
        <div class="flex flex-col sm:flex-row justify-center items-center gap-4">
            <button id="btnStartSoloBreathe" class="breathe-option-btn">
               <svg class="w-10 h-10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12 C3 6 9 6 12 12 S 15 18 21 12"></path></svg>
               <span id="breatheSoloLabel" class="text-sm mt-2 text-gray-300"></span>
            </button>
            <button id="btnStartGroupBreathe" class="breathe-option-btn">
              <svg class="w-10 h-10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 10 C3 4 9 4 12 10 S 15 16 21 10"></path><path d="M3 14 C3 8 9 8 12 14 S 15 20 21 14"></path></svg>
              <span id="breatheGroupLabel" class="text-sm mt-2 text-gray-300"></span>
            </button>
        </div>
    </div>
  </div>

  <div id="colorPickerModal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50">
    <div class="bg-black border border-gray-700 rounded-lg p-6 w-full max-w-xs sm:max-w-sm text-center relative flex flex-col">
        <div id="colorPickerHeader" class="flex items-center justify-center w-full mb-4">
            <button id="btnPrevPalette" class="p-2 rounded-full hover:bg-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path></svg>
            </button>
            <h2 id="colorPickerPaletteName" class="text-lg font-semibold mx-4 text-center flex-1 whitespace-nowrap overflow-hidden text-ellipsis flex justify-center"></h2>
            <button id="btnNextPalette" class="p-2 rounded-full hover:bg-gray-700">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path></svg>
            </button>
        </div>
        <div id="colorPickerSwatches" class="grid grid-cols-5 gap-3 justify-center"></div>
        <div id="colorPickerPagination" class="flex justify-center items-center h-8 mt-4"></div>
    </div>
  </div>

  <div id="helpModal" class="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center p-4 z-50">
    <div id="helpModalContentWrapper" class="relative bg-[#1c1c1c] rounded-lg p-6 w-full max-w-md max-h-[80vh] flex flex-col">
       <button id="btnLangToggle" class="absolute top-3 left-3 text-gray-400 hover:text-white text-sm font-bold"></button>
       <button id="btnHelpModalClose" class="absolute top-2 right-2 text-gray-400 hover:text-white">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
      </button>
      <div id="helpModalInnerContainer" class="flex flex-col min-h-0">
        <h2 id="helpModalTitle" class="text-xl font-bold text-center mb-4 text-gray-200"></h2>
        <p id="helpIntroText" class="text-base text-gray-400 italic text-center mb-6"></p>
        <div id="helpModalContent" class="overflow-y-auto space-y-4 pr-2 border-t border-gray-700 pt-4"></div>
      </div>
    </div>
  </div>

  <div id="resizeModal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50">
    <div class="bg-[#1c1c1c] rounded-lg p-6 max-w-xs w-full text-center relative">
        <button id="btnResizeModalClose" class="absolute top-3 right-3 text-gray-400 hover:text-white">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
        </button>
        <h2 id="resizeModalTitle" class="text-lg font-semibold mb-4"></h2>
        <p id="resizeModalPrompt" class="text-sm text-gray-400 mb-4"></p>
        <input type="number" id="resizeInput" class="bg-gray-700 border border-gray-600 text-white text-lg text-center rounded-lg focus:ring-gold-500 focus:border-gold-500 block w-full p-2.5" placeholder="5">
        <button id="btnConfirmResize" class="mt-6 w-full text-black font-bold py-2 px-4 rounded-lg"></button>
    </div>
  </div>


  <script>
    (function() {
      // ---- I18N Translations Object ----
      const translations = {
        splashTitle: { en: "Follow Your Intuition", he: "היום יצרתי", ru: "Следуй своей интуиции", nl: "Volg je intuïtie" },
        startCreating: { en: "Start Creating", he: "יצירה", ru: "Начать творить", nl: "Begin met creëren" },
        skip: { en: "Skip", he: "דלגו", ru: "Пропустить", nl: "Overslaan" },
        saveModal_feelsLike: { en: "feels like", he: "שם היצירה", ru: "ощущается как", nl: "voelt als" },
        saveModal_defaultFilename: { en: "Journey", he: "מסע", ru: "Путешествие", nl: "Reis" },
        saveModal_close: { en: "Close", he: "סגור", ru: "Закрыть", nl: "Sluiten" },
        saveModal_saveImage: { en: "Save Image", he: "שמירה כתמונה", ru: "Сохранить изображение", nl: "Afbeelding opslaan" },
        saveModal_saveIdea: { en: "Save Idea", he: "שמירה כרעיון", ru: "Сохранить идею", nl: "Idee opslaan" },
        saveModal_loadIdea: { en: "Load Idea", he: "טעינת רעיון", ru: "Загрузить идею", nl: "Idee laden" },
        breatheModal_solo: { en: "Solo", he: "תא תא", ru: "Соло", nl: "Solo" },
        breatheModal_group: { en: "Group", he: "צבע צבע", ru: "Группа", nl: "Groep" },
        resizeModal_title: { en: "Set Grid Size", he: "גודל הלוח החדש:", ru: "Установить размер сетки", nl: "Rasterformaat instellen" },
        resizeModal_prompt: { en: "Enter a number between 1 and 50.", he: "בין 1 ל-50", ru: "Введите число от 1 до 50.", nl: "Voer een getal in tussen 1 en 50." },
        resizeModal_confirm: { en: "Set Size", he: "קבע גודל", ru: "Установить", nl: "Instellen" },
        colorPicker_rainbow: { en: "Select rainbow brush", he: "מברשת קשת", ru: "Выбрать радужную кисть", nl: "Selecteer regenboogpenseel" },
        colorPicker_select: { en: "Select color:", he: "בחר צבע:", ru: "Выбрать цвет:", nl: "Selecteer kleur:" },
        tooltip_invert: { en: "Invert Colors", he: "היפוך צבעים", ru: "Инвертировать цвета", nl: "Kleuren omkeren" },
        tooltip_palette: { en: "Switch palette", he: "עבור לפלטת הצבעים הבאה", ru: "Сменить палитру", nl: "Wissel palet" },
        tooltip_random: { en: "Explore Mood", he: "ערבוב כל פלטת הצבעים", ru: "Исследовать настроение", nl: "Ontdek sfeer" },
        tooltip_colorPicker: { en: "Choose Color", he: "בחירת צבע", ru: "Выбрать цвет", nl: "Kies kleur" },
        tooltip_symmetry: { en: "Symmetry Mode", he: "סימטריה", ru: "Режим симметрии", nl: "Symmetriemodus" },
        tooltip_brushMode: { en: "Mode: Drag to Copy", he: "גרירה והעתקה", ru: "Режим: Перетащить для копирования", nl: "Modus: Sleep om te kopiëren" },
        tooltip_redo: { en: "Redo", he: "בצע שוב", ru: "Повторить", nl: "Opnieuw" },
        tooltip_undo: { en: "Undo", he: "בטל", ru: "Отменить", nl: "Ongedaan maken" },
        tooltip_dark: { en: "Go dark", he: "לוח כהה", ru: "Затемнить", nl: "Verduisteren" },
        tooltip_specialReset: { en: "Visit somewhere", he: "אל הלא נודע", ru: "Отправиться в неизведанное", nl: "Bezoek ergens" },
        tooltip_resetBoard: { en: "Restart", he: "נקודת התחלה", ru: "Начать заново", nl: "Herstarten" },
        tooltip_resizeUp: { en: "Rise up!", he: "הגדלת הלוח", ru: "Увеличить!", nl: "Groter worden!" },
        tooltip_resizeDown: { en: "Go minimal", he: "הקטנת הלוח", ru: "Уменьшить", nl: "Minimaliseer" },
        tooltip_gap: { en: "Grid Separator", he: "מרווח בין אריחים", ru: "Разделитель сетки", nl: "Raster-scheiding" },
        tooltip_save: { en: "Capture", he: "שמירה", ru: "Захватить", nl: "Vastleggen" },
        tooltip_breathe: { en: "Breathe", he: "נשימה", ru: "Дыхание", nl: "Ademen" },
        tooltip_tutorial: { en: "Help Guide", he: "מדריך עזרה", ru: "Справка", nl: "Hulp" },
        help_title: { en: "Controls Guide", he: "מה כל כפתור עושה?", ru: "Руководство по управлению", nl: "Gids voor besturing" },
        help_intro: { en: "Everything starts with a touch. The best way to discover is to simply tap or drag on the tiles. These tools are here to help you explore.", he: "הכל מתחיל במגע. הדרך הטובה ביותר לגלות היא פשוט ללחוץ או לגרור את האצבע על האריחים ולראות מה קורה. הכלים כאן כדי לעזור לך לחקור.", ru: "Всё начинается с прикосновения. Лучший способ исследовать — просто нажимать или перетаскивать плитки. Эти инструменты помогут вам в исследовании.", nl: "Alles begint met een aanraking. De beste manier om te ontdekken is door simpelweg op de tegels te tikken of te slepen. Deze tools zijn er om je te helpen verkennen." },
        help_category_inspiration: { en: "Inspiration & Discovery", he: "השראה וגילוי", ru: "Вдохновение и открытия", nl: "Inspiratie & Ontdekking" },
        help_category_order: { en: "Order & Organization", he: "סדר וארגון", ru: "Порядок и организация", nl: "Orde & Organisatie" },
        help_category_touch: { en: "Personal Touch", he: "מגע אישי", ru: "Личный штрих", nl: "Persoonlijke Toets" },
        help_category_expression: { en: "Expression & Creation", he: "הבעה ויצירה", ru: "Выражение и творчество", nl: "Expressie & Creatie" },
        help_category_tools: { en: "Useful Tools", he: "כלים שימושיים", ru: "Полезные инструменты", nl: "Handige Tools" },
        brushMode_paint: { en: "Paint", he: "ציור", ru: "Рисовать", nl: "Verf" },
        brushMode_copy: { en: "Copy", he: "העתקה", ru: "Копировать", nl: "Kopieer" },
        symmetry_off: { en: "Symmetry Off", he: "סימטריה: כבוי", ru: "Симметрия выключена", nl: "Symmetrie uit" },
        symmetry_vertical: { en: "Vertical Symmetry", he: "סימטריה אנכית", ru: "Вертикальная симметрия", nl: "Verticale symmetrie" },
        symmetry_horizontal: { en: "Horizontal Symmetry", he: "סימטריה אופקית", ru: "Горизонтальная симметрия", nl: "Horizontale symmetrie" },
        symmetry_mandala: { en: "Mandala Mode", he: "מנדלה", ru: "Режим мандалы", nl: "Mandala-modus" },
        palette_journey: { en: "The Journey", he: "מסע", ru: "Путешествие", nl: "De Reis" },
        paletteName_default: { en: "Default", he: "מסע", ru: "По умолчанию", nl: "Standaard" },
        paletteName_autumn: { en: "New-York Autumn", he: "סתיו בניו יורק", ru: "Нью-йоркская осень", nl: "New Yorkse Herfst" },
        paletteName_summer: { en: "Brazilian Summer", he: "קיץ ברזילאי", ru: "Бразильское лето", nl: "Braziliaanse Zomer" },
        paletteName_winter: { en: "Icelandic Winter", he: "חורף איסלנדי", ru: "Исландская зима", nl: "IJslandse Winter" },
        paletteName_spring: { en: "Japanese Spring", he: "אביב יפני", ru: "Японская весна", nl: "Japanse Lente" },
        paletteName_rainforest: { en: "Amazon Rainforest", he: "אמזונס", ru: "Тропический лес Амазонки", nl: "Amazone Regenwoud" },
        paletteName_sunrise: { en: "Desert Sunrise", he: "זריחה במדבר", ru: "Рассвет в пустыне", nl: "Woestijn zonsopgang" },
        paletteName_cherry: { en: "Cherry Blossom", he: "פריחת הדובדבן", ru: "Вишнёвый цвет", nl: "Kersenbloesem" },
        paletteName_sea: { en: "Deep Sea", he: "במעמקי הים", ru: "Глубокое море", nl: "Diepzee" },
        paletteName_noise: { en: "Brown Noise", he: "מטילי זהב", ru: "Золотой запас", nl: "Goudkoorts" },
        paletteName_cosmos: { en: "Cosmos", he: "הקיום", ru: "Космос", nl: "Kosmos" },
        paletteName_jasmine: { en: "Jasmine Dream", he: "יסמין", ru: "Жасминовая мечта", nl: "Jasmijndroom" },
        help_invert: { en: 'Invert all colors to their opposite in the current palette.', he: 'הופך כל צבע על הלוח לצבע המשלים שלו בפלטה הנוכחית.', ru: 'Инвертирует все цвета на их противоположные в текущей палитре.', nl: 'Keert alle kleuren om naar hun tegenovergestelde in het huidige palet.' },
        help_palette: { en: 'Cycle through available color palettes.', he: 'מעבר בין פלטות צבעים.', ru: 'Переключает доступные цветовые палитры.', nl: 'Bladert door beschikbare kleurpaletten.' },
        help_random: { en: 'Fill the entire grid with random colors from the current palette.', he: 'מילוי הלוח בצבעים אקראיים מהפלטה הנוכחית.', ru: 'Заполняет всю сетку случайными цветами из текущей палитры.', nl: 'Vult het hele raster met willekeurige kleuren uit het huidige palet.' },
        help_colorPicker: { en: 'Select a specific color to paint with. Tap again to deselect.', he: 'בחירת צבע ספציפי לציור. לחץ שוב לביטול הבחירה.', ru: 'Выбирает определённый цвет для рисования. Нажмите ещё раз, чтобы отменить выбор.', nl: 'Selecteert een specifieke kleur om mee te schilderen. Tik nogмаals om de selectie op te heffen.' },
        help_symmetry: { en: 'Cycle through symmetry modes: Off, Vertical, Horizontal, and Mandala.', he: 'מעבר בין מצבי סימטריה: כבוי, אנכי, אופקי ומנדלה.', ru: 'Переключает режимы симметрии: выкл., вертикальная, горизонтальная и мандала.', nl: 'Schakelt tussen symmetriemodi: Uit, Verticaal, Horizontaal en Mandala.' },
        help_brushMode: { en: 'Toggle between Paint mode (drag to paint) and Copy mode (tap source, then tap destination).', he: 'שינוי מצב בין ציור (גרירה) להעתקה (הקשה על מקור ואז על יעד).', ru: 'Переключает между режимом рисования (перетаскивание) и режимом копирования (нажмите на источник, затем на место назначения).', nl: 'Schakelt tussen Verfmodus (slepen om te schilderen) en Kopieermodus (tik op bron, dan op bestemming).' },
        help_redo: { en: 'Redo the last action that was undone.', he: 'ביצוע מחדש של הפעולה האחרונה שבוטלה.', ru: 'Повторяет последнее отменённое действие.', nl: 'Voert de laatste ongedaan gemaakte actie opnieuw uit.' },
        help_undo: { en: 'Undo the last action.', he: 'ביטול הפעולה האחרונה.', ru: 'Отменяет последнее действие.', nl: 'Maakt de laatste actie ongedaan.' },
        help_dark: { en: 'Fill the entire grid with the darkest color from the current palette.', he: 'מילוי הלוח בצבע הכהה ביותר מהפלטה הנוכחית.', ru: 'Заполняет всю сетку самым тёмным цветом из текущей палитры.', nl: 'Vult het hele raster met de donkerste kleur uit het huidige palet.' },
        help_specialReset: { en: 'Generate a completely new grid with a random size, gap, and color palette.', he: 'יצירת לוח חדש לגמרי עם גודל, רווח ופלטת צבעים אקראיים.', ru: 'Создаёт совершенно новую сетку со случайным размером, зазором и цветовой палитрой.', nl: 'Genereert een compleet nieuw raster met een willekeurige grootte, tussenruimte en kleurenpalet.' },
        help_resetBoard: { en: 'Restart the grid to its original "Journey" state.', he: 'איפוס הלוח למצב ההתחלתי של "מסע".', ru: 'Перезапускает сетку в исходное состояние "Путешествие".', nl: 'Herstart het raster naar de oorspronkelijke "Reis"-staat.' },
        help_resizeUp: { en: 'Increase the number of tiles on the grid. Long-press to set a custom size.', he: 'הגדלת מספר האריחים בלוח. לחיצה ארוכה לקביעת גודל מותאם.', ru: 'Увеличивает количество плиток на сетке. Долгое нажатие для установки пользовательского размера.', nl: 'Verhoogt het aantal tegels op het raster. Druk lang om een aangaste grootte in te stellen.' },
        help_resizeDown: { en: 'Decrease the number of tiles on the grid. Long-press to set a custom size.', he: 'הקטנת מספר האריחים בלוח. לחיצה ארוכה לקביעת גודל מותאם.', ru: 'Уменьшает количество плиток на сетке. Долгое нажатие для установки пользовательского размера.', nl: 'Verlaagt het aantal tegels op het raster. Druk lang om een aangaste grootte in te stellen.' },
        help_gap: { en: 'Adjust the spacing between the tiles.', he: 'שינוי המרווחים בין האריחים.', ru: 'Регулирует расстояние между плитками.', nl: 'Past de ruimte tussen de tegels aan.' },
        help_save: { en: 'Open the save menu to export your creation as an image or project file.', he: 'פתיחת תפריט השמירה לייצוא היצירה כתמונה או כקובץ פרויקט.', ru: 'Открывает меню сохранения для экспорта вашего творения в виде изображения или файла проекта.', nl: 'Opent het opslagmenu om je creatie te exporteren als een afbeelding of projectbestand.' },
        help_breathe: { en: 'Start a calming, pulsing animation across the grid.', he: 'הפעלת אנימציית נשימה מרגיעה על הלוח.', ru: 'Запускает успокаивающую, пульсирующую анимацию по всей сетке.', nl: 'Start een kalmerende, pulserende animatie over het raster.' },
        help_tutorial: { en: 'Opens this guide.', he: 'פתיחת מדריך זה.', ru: 'Открывает это руководство.', nl: 'Opent deze gids.' },
        error_invalidFile: { en: 'Error: The selected file is not a valid project file.', he: 'שגיאה: הקובץ שנבחר אינו קובץ פרויקט תקין.', ru: 'Ошибка: Выбранный файл не является допустимым файлом проекта.', nl: 'Fout: Het geselecteerde bestand is geen geldig projectbestand.' },
        error_readFile: { en: 'Error: Could not read the project file. It might be corrupted.', he: 'שגיאה: לא ניתן לקרוא את קובץ הפרויקט. ייתכן שהוא פגום.', ru: 'Ошибка: Не удалось прочитать файл проекта. Возможно, он повреждён.', nl: 'Fout: Kon het projectbestand niet lezen. Het is mogelijk beschadigd.' }
      };

      // ---- Language & State ----
      const availableLangs = ['en', 'he', 'ru', 'nl'];
      let currentLang = 'en';
      
      const PALETTES = [
        { name: translations.paletteName_default[currentLang], originalName: "Default", emoji: '🌓', colors: ["#000000", "#424242", "#7B1FA2", "#5E35B1", "#3949AB", "#673AB7", "#8E24AA", "#AD1457", "#3F51B5", "#B71C1C", "#9C27B0", "#C2185B", "#C62828", "#2E7D32", "#D32F2F", "#D81B60", "#AB47BC", "#757575", "#1976D2", "#E91E63", "#E53935", "#FF1744", "#EC407A", "#F44336", "#1E88E5", "#0097A7", "#EF5350", "#F4511E", "#FF4081", "#43A047", "#FF5252", "#FF5722", "#2196F3", "#F06292", "#4CAF50", "#FF7043", "#F57C00", "#9E9E9E", "#42A5F5", "#FB8C00", "#66BB6A", "#FF8C00", "#00BCD4", "#AFB42B", "#F48FB1", "#FF9800", "#8BC34A", "#26C6DA", "#FFA726", "#BDBDBD", "#9CCC65", "#FBC02D", "#CDDC39", "#FFE082", "#FFEE58", "#FFF176", "#FFD700", "#FDD835", "#F5F5F5", "#FFFFFF"] },
        { name: translations.paletteName_autumn[currentLang], originalName: "New-York Autumn", emoji: '🍂', colors: ["#3E2723", "#4E342E", "#8B0000", "#37474F", "#5D4037", "#2F4F4F", "#8B3A3A", "#8B4513", "#A52A2A", "#B22222", "#795548", "#556B2F", "#607D8B", "#808000", "#6B8E23", "#D2691E", "#B8860B", "#CD853F", "#FF7F50", "#C2A14A", "#FF8C00", "#DAA520", "#F4A460"] },
        { name: translations.paletteName_summer[currentLang], originalName: "Brazilian Summer", emoji: '☀️', colors: ["#2962FF", "#F50057", "#FF1493", "#1E90FF", "#FF5722", "#00A86B", "#FF69B4", "#FF7F50", "#00B0FF", "#00C853", "#00BFFF", "#2ECC71", "#00C4FF", "#64DD17", "#00E676", "#40E0D0", "#FFC107", "#1DE9B6", "#FFD700", "#FDD835", "#00FF7F", "#18FFFF", "#FFEB3B"] },
        { name: translations.paletteName_winter[currentLang], originalName: "Icelandic Winter", emoji: '❄️', colors: ["#263238", "#37474F", "#455A64", "#546E7A", "#78909C", "#9E9E9E", "#03A9F4", "#90A4AE", "#29B6F6", "#4FC3F7", "#B0BEC5", "#BDBDBD", "#4DD0E1", "#81D4FA", "#80DEEA", "#CFD8DC", "#B3E5FC", "#A7FFEB", "#ECEFF1", "#E1F5FE", "#E6F7FF", "#F5F5F5", "#FFFFFF"] },
        { name: translations.paletteName_spring[currentLang], originalName: "Japanese Spring", emoji: '🌸', colors: ["#B39DDB", "#F48FB1", "#64B5F6", "#81C784", "#90CAF9", "#87CEFA", "#81D4FA", "#A5D6A7", "#D1C4E9", "#FFB7C5", "#F8BBD0", "#80DEEA", "#FFC0CB", "#C1E1C1", "#FFD1DC", "#B3E5FC", "#DCEDC8", "#E6E6FA", "#FFECB3", "#A7FFEB", "#FFF59D", "#FFF9C4", "#FFF8DC"] },
        { name: translations.paletteName_rainforest[currentLang], originalName: "Amazon Rainforest", emoji: '🌳', colors: ["#013220", "#0B5345", "#145A32", "#0E6655", "#196F3D", "#117864", "#117A65", "#1D8348", "#1E8449", "#138D75", "#229954", "#239B56", "#16A085", "#27AE60", "#28B463", "#45B39D", "#52BE80", "#2ECC71", "#48C9B0", "#73C6B6", "#58D68D", "#82E0AA", "#A9DFBF"] },
        { name: translations.paletteName_sunrise[currentLang], originalName: "Desert Sunrise", emoji: '🐪', colors: ["#4B0610", "#5A0C16", "#69121C", "#781822", "#861E28", "#95242E", "#A42A34", "#B33A3A", "#C23640", "#C94752", "#D15864", "#D86976", "#E07A88", "#E78B9A", "#EE9CAC", "#DDA0DD", "#BDB0D0", "#C3B1E1", "#F1A8AB", "#F3B4A9", "#D8BFD8", "#F6BFA8", "#F8CBA6", "#FAD6A5", "#E6E6FA"] },
        { name: translations.paletteName_cherry[currentLang], originalName: "Cherry Blossom", emoji: '桜', iconHTML: '<span style="color: #FFB6C1;">桜</span>', colors: ["#69476E", "#86688B", "#8F6AAD", "#A284C2", "#A389A4", "#BC8F8F", "#B59ECB", "#D4A3A3", "#C0A9BD", "#BDB0D0", "#C3B1E1", "#C9B7D4", "#E1B5B5", "#D8BFD8", "#E0BBE4", "#D6CADD", "#FBC4AB", "#EECBCB", "#FFC4D0", "#DCD0E2", "#FFD1DC", "#E6DCE5", "#F4DEDE", "#FFDDE1", "#F8E9E9"] },
        { name: translations.paletteName_sea[currentLang], originalName: "Deep Sea", emoji: '🌊', colors: ["#000000", "#0B0C10", "#1C1C1C", "#000080", "#252525", "#00008B", "#191970", "#0000CD", "#36454F", "#483D8B", "#2F4F4F", "#0000FF", "#8A2BE2", "#9932CC", "#6A5ACD", "#008080", "#008B8B", "#BA55D3", "#9370DB", "#5F9EA0", "#20B2AA", "#66CDAA", "#40E0D0", "#00FFFF", "#7FFFD4"] },
        { name: translations.paletteName_noise[currentLang], originalName: "Brown Noise", iconHTML: '<svg viewBox="0 0 24 24" style="width: var(--icon-size); height: var(--icon-size);"><polygon points="7,3 17,3 21,21 3,21" style="fill:#FFD700;" /></svg>', colors: ["#3E2F00", "#523F00", "#665000", "#7A6000", "#8E7000", "#A28000", "#B69000", "#CAA000", "#DEB000", "#F2C000", "#F4C306", "#F6C70C", "#F8CA12", "#FACC18", "#FCD01E", "#FED324", "#FFD52A", "#FFD700", "#FFD730", "#FFD936", "#FFDB3C", "#FFDD42", "#FFDF48", "#FFE14E", "#FFE354"] },
        { name: translations.paletteName_cosmos[currentLang], originalName: "Cosmos", emoji: '🌌', colors: ["#000000", "#0B0C10", "#00008B", "#1F2833", "#191970", "#263238", "#4B0082", "#37474F", "#483D8B", "#8A2BE2", "#BA55D3", "#9370DB", "#1E90FF", "#FF00FF", "#DA70D6", "#FF69B4", "#00BFFF", "#40E0D0", "#B0E0E6", "#FFFACD", "#F8F8FF", "#E0FFFF", "#FFFFFF"] },
        { name: translations.paletteName_jasmine[currentLang], originalName: "Jasmine Dream", iconHTML: '<svg viewBox="0 0 24 24" style="width: var(--icon-size); height: var(--icon-size);"><defs><linearGradient id="jasmineGradient" gradientTransform="rotate(90)"><stop offset="5%" stop-color="#AB6BB7" /><stop offset="95%" stop-color="#4B0082" /></linearGradient></defs><g transform="translate(12,12) rotate(18)"><path d="M0,-11 C 5,-6 5,5 0,1 C -5,5 -5,-6 0,-11 Z" transform="rotate(0)" fill="url(#jasmineGradient)"/><path d="M0,-11 C 5,-6 5,5 0,1 C -5,5 -5,-6 0,-11 Z" transform="rotate(72)" fill="url(#jasmineGradient)"/><path d="M0,-11 C 5,-6 5,5 0,1 C -5,5 -5,-6 0,-11 Z" transform="rotate(144)" fill="url(#jasmineGradient)"/><path d="M0,-11 C 5,-6 5,5 0,1 C -5,5 -5,-6 0,-11 Z" transform="rotate(216)" fill="url(#jasmineGradient)"/><path d="M0,-11 C 5,-6 5,5 0,1 C -5,5 -5,-6 0,-11 Z" transform="rotate(288)" fill="url(#jasmineGradient)"/></g><circle cx="12" cy="12" r="2.5" fill="#FFD700"/></svg>', colors: ["#4B0082", "#5A189A", "#682A7A", "#6A1E97", "#7B1E8A", "#743993", "#804090", "#854772", "#8C4888", "#8F588C", "#986089", "#9B5AA3", "#A0636A", "#9E6F80", "#AB6BB7", "#A97585", "#A8769C", "#AE7E82", "#B97F62", "#B885B1", "#B39178", "#B59095", "#C4927E", "#C69A7B", "#D29B5A", "#C59EAA", "#C2AA8E", "#C9AD70", "#DEAE77", "#D2B7A3", "#E1B674", "#D0C187", "#E3BF68", "#E0CF9C", "#E5D680", "#F0E595"] }
      ];

      // ---- Onboarding State ----
      const ONBOARDING_STORAGE_KEY = 'colorGridOnboardingComplete';
      let isOnboarding = false;
      let onboardingStep = 0; // 0 = inactive, 1 = start, 2 = undo/redo, 3 = more tools, 4 = full UI

      function getText(key) {
        if (!translations[key] || !translations[key][currentLang]) {
            console.warn(`Translation key not found for lang '${currentLang}': ${key}`);
            // Fallback to English if translation is missing
            return translations[key] ? translations[key]['en'] : key;
        }
        return translations[key][currentLang];
      }

      let activePaletteIndex = 0;
      let n = 11;
      const GOLD = '#FFD700';
      let separatorPx = 0;
      let isBrushModeOn = true; 
      let hasPerformedInitialAutofill = false; 
      let hasTriggeredFirstNudge = false;
      let hasUsedRandomize = false;
      let isAnimating = false;
      let isBreathing = false;
      let selectedColor = null;
      let isRainbowModeActive = false;
      let selectedColorIndex = -1;
      let colorPickerPage = 0;
      const COLORS_PER_PAGE = 24;

      const SYMMETRY_MODES = ['off', 'vertical', 'horizontal', 'mandala'];
      let symmetryMode = 'off';
      const SEPARATORS = [6, 5, 3, 2, 0];
      const SIZES = [49, 35, 27, 21, 15, 11, 9, 7, 5, 3];
      const LONG_PRESS_SHOW_MS = 400;
      
      const tiles = () => Array.from(board.querySelectorAll('.tile'));
      const isGold = (el) => !!el.dataset.goldOverlay;
      const paletteLen = () => palette().length;
      const norm = (k, m = paletteLen()) => ((k % m) + m) % m;

      const HISTORY_LIMIT = 20;
      let history = [];
      let future = [];

      // ---- Element Cache ----
      const appContainer = document.getElementById('appContainer');
      const appShell = document.querySelector('.app-shell');
      const controlsContainer = document.getElementById('controlsContainer');
      const board = document.getElementById('board');
      const boardOverlay = document.getElementById('boardOverlay');
      const btnRandom = document.getElementById('btnRandom');
      const btnPalette = document.getElementById('btnPalette');
      const btnGap = document.getElementById('btnGap');
      const btnUndo = document.getElementById('btnUndo');
      const btnRedo = document.getElementById('btnRedo');
      const btnInvert = document.getElementById('btnInvert');
      const btnBrushMode = document.getElementById('btnBrushMode');
      const btnSpecialReset = document.getElementById('btnSpecialReset');
      const btnTutorial = document.getElementById('btnTutorial');
      const btnDark = document.getElementById('btnDark');
      const root = document.documentElement;
      const tileClasses = 'tile aspect-square w-full outline-none focus-visible:ring-inset focus-visible:ring-4 focus-visible:ring-white/90';
      const btnShowBreatheMenu = document.getElementById('btnShowBreatheMenu');
      const btnSymmetry = document.getElementById('btnSymmetry');
      const btnColorPicker = document.getElementById('btnColorPicker');
      const originalColorPickerIconHTML = btnColorPicker.innerHTML;
      const btnExitBreathe = document.getElementById('btnExitBreathe');
      const btnResetBoard = document.getElementById('btnResetBoard');
      const btnResizeUp = document.getElementById('btnResizeUp');
      const btnResizeDown = document.getElementById('btnResizeDown');
      const btnSave = document.getElementById('btnSave');
      const saveModal = document.getElementById('saveModal');
      const imagePreview = document.getElementById('imagePreview');
      const btnModalClose = document.getElementById('btnModalClose');
      const fileNameInput = document.getElementById('fileNameInput');
      let generatedImageFile = null;
      const btnSaveImage = document.getElementById('btnSaveImage');
      const btnSaveProjectIdea = document.getElementById('btnSaveProjectIdea');
      const btnLoadProjectIdea = document.getElementById('btnLoadProjectIdea');
      const projectFileInput = document.getElementById('projectFileInput');
      const breatheModal = document.getElementById('breatheModal');
      const btnBreatheModalClose = document.getElementById('btnBreatheModalClose');
      const btnStartSoloBreathe = document.getElementById('btnStartSoloBreathe');
      const btnStartGroupBreathe = document.getElementById('btnStartGroupBreathe');
      const colorPickerModal = document.getElementById('colorPickerModal');
      const colorPickerHeader = document.getElementById('colorPickerHeader');
      const colorPickerPaletteName = document.getElementById('colorPickerPaletteName');
      const colorPickerSwatches = document.getElementById('colorPickerSwatches');
      const btnPrevPalette = document.getElementById('btnPrevPalette');
      const btnNextPalette = document.getElementById('btnNextPalette');
      const colorPickerPagination = document.getElementById('colorPickerPagination');
      const helpModal = document.getElementById('helpModal');
      const btnHelpModalClose = document.getElementById('btnHelpModalClose');
      const resizeModal = document.getElementById('resizeModal');
      const btnResizeModalClose = document.getElementById('btnResizeModalClose');
      const resizeInput = document.getElementById('resizeInput');
      const btnConfirmResize = document.getElementById('btnConfirmResize');
      const longPressOverlay = document.getElementById('longPressOverlay');
      const longPressDisplay = document.getElementById('longPressDisplay');
      let longPressTimer = null;
      let wasLongPress = false;
      const btnLangToggle = document.getElementById('btnLangToggle');

      function palette() { return PALETTES[activePaletteIndex].colors; }

      function getCurrentState() {
        return { 
          n, 
          activePaletteIndex, 
          paletteName: PALETTES[activePaletteIndex].originalName, 
          separatorPx, 
          symmetryMode,
          selectedColor,
          isRainbowModeActive,
          tiles: tiles().map(el => ({ k: getIndex(el), isGold: isGold(el) })) 
        };
      }
      function areStatesEqual(stateA, stateB) {
        if (!stateA || !stateB) return false;
        if (stateA.n !== stateB.n || stateA.activePaletteIndex !== stateB.activePaletteIndex || stateA.separatorPx !== stateB.separatorPx || stateA.symmetryMode !== stateB.symmetryMode || stateA.selectedColor !== stateB.selectedColor || stateA.isRainbowModeActive !== stateB.isRainbowModeActive || stateA.tiles.length !== stateB.tiles.length) return false;
        for (let i = 0; i < stateA.tiles.length; i++) {
          if (stateA.tiles[i].k !== stateB.tiles[i].k || stateA.tiles[i].isGold !== stateB.tiles[i].isGold) return false;
        }
        return true;
      }
      function applyState(state) {
        let paletteIdx = PALETTES.findIndex(p => p.originalName === state.paletteName);
        if (paletteIdx === -1) {
            paletteIdx = state.activePaletteIndex;
        }
        activePaletteIndex = paletteIdx >= 0 && paletteIdx < PALETTES.length ? paletteIdx : 0;
        
        separatorPx = state.separatorPx;
        symmetryMode = state.symmetryMode || 'off';

        selectedColor = state.selectedColor || null;
        isRainbowModeActive = state.isRainbowModeActive || false;
        if (selectedColor) {
            selectedColorIndex = palette().indexOf(selectedColor);
            if (selectedColorIndex === -1) {
                selectedColor = null;
            }
        } else {
            selectedColorIndex = -1;
        }
        updateGlowEffect();
        updateColorPickerButtonUI();

        updatePaletteHeader();
        applySeparator();
        updateSymmetryUI();
        if (n !== state.n) {
            n = state.n;
            buildBoard(n, false);
        }
        const tileElements = tiles();
        state.tiles.forEach((tileState, i) => {
            if (tileElements[i]) {
                const el = tileElements[i];
                if (tileState.isGold) { applyGoldOverlay(el); } 
                else { delete el.dataset.goldOverlay; setIndex(el, tileState.k); }
            }
        });
      }
      function pushHistory(state) {
        history.push(state);
        if (history.length > HISTORY_LIMIT) { history.shift(); }
        future = [];
        updateUndoRedoButtons();
      }
      function performAction(actionFn) {
        const beforeState = getCurrentState();
        actionFn();
        const afterState = getCurrentState();
        if (!areStatesEqual(beforeState, afterState)) {
            pushHistory({ before: beforeState, after: afterState });
            hasPerformedInitialAutofill = true;
        }
      }
      function undo() {
        if (history.length === 0) return;
        const lastAction = history.pop();
        future.push(lastAction);
        applyState(lastAction.before);
        clearAllHighlights();
        updateUndoRedoButtons();
      }
      function redo() {
        if (future.length === 0) return;
        const nextAction = future.pop();
        history.push(nextAction);
        applyState(nextAction.after);
        clearAllHighlights();
        updateUndoRedoButtons();
      }
      function updateUndoRedoButtons() {
        btnUndo.disabled = history.length === 0;
        btnRedo.disabled = future.length === 0;
      }

      function getPaletteColor(k) { return palette()[norm(k)]; }
      function createTile(idx = 0) {
        const d = document.createElement('div');
        d.className = tileClasses;
        d.setAttribute('role', 'gridcell');
        d.setAttribute('tabindex', '0');
        setIndex(d, idx);
        return d;
      }
      function setIndex(el, k) {
        el.dataset.k = String(k);
        if (!isGold(el)) {
          el.style.background = getPaletteColor(k);
        }
      }
      function getIndex(el) { return parseInt(el.dataset.k || '0', 10); }
      function applyGoldOverlay(el) { el.style.background = GOLD; el.dataset.goldOverlay = '1'; }
      function clearGoldOverlay(el) {
        if (isGold(el)) {
          delete el.dataset.goldOverlay;
          el.style.background = getPaletteColor(getIndex(el));
        }
      }
      function clearAllHighlights() {
        tiles().forEach(el => {
            el.classList.remove('source-highlight', 'target-highlight');
        });
      }
      function buildBoard(size, applyGold = true) {
        root.style.setProperty('--grid-size', size);
        board.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (let i = 0; i < size * size; i++) {
            const tile = createTile(0);
            if(applyGold) applyGoldOverlay(tile);
            frag.appendChild(tile);
        }
        board.appendChild(frag);
        if (applyGold) { hasPerformedInitialAutofill = false; }
      }
      function updatePaletteHeader() {
        const pal = PALETTES[activePaletteIndex];
        if (pal.iconHTML) { btnPalette.innerHTML = pal.iconHTML; } 
        else { btnPalette.innerHTML = ''; btnPalette.textContent = pal.emoji; }
        const label = `${getText('tooltip_palette')}: ${pal.name} (${activePaletteIndex + 1}/${PALETTES.length})`;
        btnPalette.title = getText('tooltip_palette');
        btnPalette.setAttribute('aria-label', label);
      }
      function applySeparator() {
        root.style.setProperty('--gap-px', separatorPx + 'px');
        root.style.setProperty('--tile-radius', (separatorPx === 0 ? '0px' : '2px'));
        btnGap.title = getText('tooltip_gap');
        btnGap.setAttribute('aria-label', getText('tooltip_gap'));
      }

      async function animateBoardTransition(actionFn) {
        if (isAnimating) return;
        isAnimating = true;
        boardOverlay.style.opacity = '1';
        await new Promise(resolve => setTimeout(resolve, 350));
        actionFn();
        await new Promise(resolve => setTimeout(resolve, 50));
        boardOverlay.style.opacity = '0';
        await new Promise(resolve => setTimeout(resolve, 350));
        isAnimating = false;
      }
      
      function applyInitialPattern() {
        const currentTiles = tiles();
        const BLACK_INDEX = 0; // Black is the first color in the default palette

        // Calculate the center tile index
        const centerIndex = Math.floor((n * n) / 2);

        currentTiles.forEach((tile, index) => {
          clearGoldOverlay(tile); // Clear any existing gold overlays first
          if (index === centerIndex) {
            // This is the center tile, make it gold
            applyGoldOverlay(tile);
          } else {
            // All other tiles are black
            setIndex(tile, BLACK_INDEX);
          }
        });
      }

      function cycleSeparator() {
          performAction(() => {
            const seq = SEPARATORS;
            let idx = seq.indexOf(separatorPx);
            if (idx === -1) { idx = seq.indexOf(seq.reduce((p, c) => (Math.abs(c - separatorPx) < Math.abs(p - separatorPx) ? c : p))); }
            separatorPx = seq[(idx + 1) % seq.length];
            applySeparator();
          });
      }
      function fillRandom() {
        tiles().forEach(el => {
          clearGoldOverlay(el);
          setIndex(el, Math.floor(Math.random() * paletteLen()));
        });
      }
      function randomizeAll() {
        performAction(fillRandom);
        hasUsedRandomize = true;
      }

      function getDarkestColorIndex(colors) {
          let darkestIndex = 0;
          let minLuminance = 1;
          colors.forEach((hex, index) => {
              if (!hex.startsWith('#') || hex.length < 7) return;
              const r = parseInt(hex.slice(1, 3), 16) / 255;
              const g = parseInt(hex.slice(3, 5), 16) / 255;
              const b = parseInt(hex.slice(5, 7), 16) / 255;
              const luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b;
              if (luminance < minLuminance) {
                  minLuminance = luminance;
                  darkestIndex = index;
              }
          });
          return darkestIndex;
      }

      function goDark() {
        const darkestIndex = getDarkestColorIndex(palette());
        tiles().forEach(el => {
          clearGoldOverlay(el);
          setIndex(el, darkestIndex);
        });
      }

      function goDarkAction() {
        animateBoardTransition(() => performAction(goDark));
      }
      
      function invertGrid() {
        performAction(() => {
            const len = paletteLen();
            tiles().forEach(el => {
                const currentIndex = getIndex(el);
                const invertedIndex = (len - 1) - currentIndex;
                setIndex(el, invertedIndex);
            });
        });
      }
      
      function resetSelectedColor() {
          selectedColor = null;
          selectedColorIndex = -1;
          isRainbowModeActive = false;
          updateGlowEffect();
          updateColorPickerButtonUI();
      }

      function resetToGoldAndDefaultPalette() {
        performAction(() => {
            activePaletteIndex = 0;
            separatorPx = 0;
            n = 11;
            symmetryMode = 'off';
            resetSelectedColor();
            updatePaletteHeader();
            applySeparator();
            updateSymmetryUI();
            buildBoard(n, false); 
            applyInitialPattern();
            hasPerformedInitialAutofill = true;
        });
        setBrushMode(true);
      }

      function specialReset() {
        activePaletteIndex = Math.floor(Math.random() * PALETTES.length);
        separatorPx = SEPARATORS[Math.floor(Math.random() * SEPARATORS.length)];
        n = SIZES[Math.floor(Math.random() * SIZES.length)];
        resetSelectedColor();
        updatePaletteHeader();
        applySeparator();
        buildBoard(n, false);
        fillRandom();
        hasPerformedInitialAutofill = true;
      }
      
      function handlePaletteSwitch(backwards = false) {
        const len = PALETTES.length;
        activePaletteIndex = (activePaletteIndex + (backwards ? -1 : 1) + len) % len;
        resetSelectedColor();
        updatePaletteHeader();
        if (!hasPerformedInitialAutofill) {
            tiles().forEach(el => { clearGoldOverlay(el); setIndex(el, 0); });
        } else {
            tiles().forEach(el => {
                if (isGold(el)) { delete el.dataset.goldOverlay; }
                el.style.background = palette()[norm(getIndex(el))];
            });
        }
      }

      function switchPalette(backwards = false) {
        const shouldTriggerNudge = !hasUsedRandomize && !hasTriggeredFirstNudge;
        performAction(() => handlePaletteSwitch(backwards));
        if (shouldTriggerNudge) {
            hasTriggeredFirstNudge = true;
            btnRandom.classList.add('glow-animation');
            setTimeout(() => { btnRandom.classList.remove('glow-animation'); }, 4000);
        }
      }
      
      function _performResize(newSize) {
        const oldStates1D = tiles().map(el => ({ k: getIndex(el), isGold: isGold(el) }));
        const oldSize = n;
        const oldStates2D = [];
        for (let i = 0; i < oldSize; i++) {
            oldStates2D.push(oldStates1D.slice(i * oldSize, (i + 1) * oldSize));
        }
        n = newSize;
        buildBoard(n, false);
        const newTiles = tiles();
        const diff = oldSize - newSize;
        const offset = Math.floor(Math.abs(diff) / 2);
        if (newSize < oldSize) {
            for (let row = 0; row < newSize; row++) {
                for (let col = 0; col < newSize; col++) {
                    const newIndex = row * newSize + col;
                    const oldRowInOldGrid = row + offset;
                    const oldColInOldGrid = col + offset;
                    if (oldRowInOldGrid < oldSize && oldColInOldGrid < oldSize) {
                        const oldState = oldStates2D[oldRowInOldGrid][oldColInOldGrid];
                        if (newTiles[newIndex] && oldState) {
                            if (oldState.isGold) { applyGoldOverlay(newTiles[newIndex]); } 
                            else { clearGoldOverlay(newTiles[newIndex]); setIndex(newTiles[newIndex], oldState.k); }
                        }
                    }
                }
            }
        } else {
            for (let row = 0; row < newSize; row++) {
                for (let col = 0; col < newSize; col++) {
                    const newIndex = row * newSize + col;
                    const newTile = newTiles[newIndex];
                    const oldRowInOldGrid = row - offset;
                    const oldColInOldGrid = col - offset;
                    const isWithinOldBounds = oldRowInOldGrid >= 0 && oldRowInOldGrid < oldSize && oldColInOldGrid >= 0 && oldColInOldGrid < oldSize;
                    if (isWithinOldBounds) {
                        const oldState = oldStates2D[oldRowInOldGrid][oldColInOldGrid];
                        if (oldState) {
                            if (oldState.isGold) { applyGoldOverlay(newTile); } 
                            else { clearGoldOverlay(newTile); setIndex(newTile, oldState.k); }
                        }
                    } else {
                        clearGoldOverlay(newTile);
                        setIndex(newTile, 0);
                    }
                }
            }
        }
      }

      function resizeGrid(increase = false) {
        const seq = SIZES;
        let newSize;
        if (increase) {
            newSize = [...seq].reverse().find(size => size > n);
            if (newSize === undefined) newSize = seq[0];
        } else {
            newSize = seq.find(size => size < n);
            if (newSize === undefined) newSize = seq[seq.length - 1];
        }
        if (newSize === n) return;
        animateBoardTransition(() => performAction(() => _performResize(newSize)));
      }


      function setBrushMode(isBrushOn) {
          isBrushModeOn = isBrushOn;
          btnBrushMode.classList.toggle('brush-on', isBrushOn);
          const newTitle = isBrushOn ? getText('brushMode_paint') : getText('brushMode_copy');
          btnBrushMode.title = newTitle;
          btnBrushMode.setAttribute('aria-label', newTitle);
          clearAllHighlights();
          if (pointerState.dragSource) pointerState.dragSource = null;
      }
      function toggleBrushMode() {
          setBrushMode(!isBrushModeOn);
      }
      function closeModal() {
        saveModal.classList.remove('modal-visible');
        if (imagePreview.src) { URL.revokeObjectURL(imagePreview.src); }
        imagePreview.src = '';
        generatedImageFile = null;
      }
      async function savePNG() {
        btnSave.disabled = true;
        clearAllHighlights();
        tiles().forEach(el => el.classList.remove('ring-inset', 'ring-4', 'ring-white', 'ring-white/90'));
        if (separatorPx === 0) { board.classList.add('no-gap-fix'); }
        try {
            const boardCanvas = await html2canvas(board, { backgroundColor: null, scale: 2 });
            const padding = 50;
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = boardCanvas.width + padding;
            finalCanvas.height = boardCanvas.height + padding;
            const ctx = finalCanvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
            ctx.drawImage(boardCanvas, padding / 2, padding / 2);
            finalCanvas.toBlob(async (blob) => {
                if (!blob) { console.error('Blob creation failed'); btnSave.disabled = false; return; }
                generatedImageFile = new File([blob], 'board.png', { type: 'image/png' });
                imagePreview.src = URL.createObjectURL(blob);
                fileNameInput.value = PALETTES[activePaletteIndex]?.originalName === 'Default' ? getText('saveModal_defaultFilename') : PALETTES[activePaletteIndex]?.name || getText('saveModal_defaultFilename');
                saveModal.classList.add('modal-visible');
                btnSave.disabled = false;
            }, 'image/png');
        } catch (err) {
            console.error("Failed to save PNG:", err);
            btnSave.disabled = false;
        } finally {
            if (separatorPx === 0) { board.classList.remove('no-gap-fix'); }
        }
      }
      function getSanitizedFileName(extension) {
        let defaultName = PALETTES[activePaletteIndex]?.originalName === 'Default' ? getText('saveModal_defaultFilename') : PALETTES[activePaletteIndex]?.name;
        let fileName = fileNameInput.value.trim() || defaultName || 'Creation';
        return fileName.replace(/[<>:"/\\|?*]/g, '_') + `.${extension}`;
      }

      function getSymmetricIndices(index) {
          if (symmetryMode === 'off') return [index];
          const row = Math.floor(index / n);
          const col = index % n;
          const N = n - 1;
          const indices = new Set([index]);
          if (symmetryMode === 'horizontal' || symmetryMode === 'mandala') {
              const hCol = N - col;
              if (hCol !== col) indices.add(row * n + hCol);
          }
          if (symmetryMode === 'vertical' || symmetryMode === 'mandala') {
              const vRow = N - row;
              if (vRow !== row) indices.add(vRow * n + col);
          }
          if (symmetryMode === 'mandala') {
              const hCol = N - col;
              const vRow = N - row;
              if (hCol !== col && vRow !== row) indices.add(vRow * n + hCol);
          }
          return Array.from(indices);
      }
      
      function updateSymmetryButtonUI() {
          const parts = {
              top: btnSymmetry.querySelector('.part.top'),
              bottom: btnSymmetry.querySelector('.part.bottom'),
              left: btnSymmetry.querySelector('.part.left'),
              right: btnSymmetry.querySelector('.part.right'),
          };
          const activeColor = GOLD;
          const inactiveColor = 'transparent';
          Object.values(parts).forEach(p => { if(p) p.style.stroke = inactiveColor; });
          if (symmetryMode === 'vertical') {
              if(parts.top) parts.top.style.stroke = activeColor;
              if(parts.bottom) parts.bottom.style.stroke = activeColor;
          } else if (symmetryMode === 'horizontal') {
              if(parts.left) parts.left.style.stroke = activeColor;
              if(parts.right) parts.right.style.stroke = activeColor;
          } else if (symmetryMode === 'mandala') {
              Object.values(parts).forEach(p => { if(p) p.style.stroke = activeColor; });
          }
          let titleKey;
          switch (symmetryMode) {
              case 'vertical': titleKey = 'symmetry_vertical'; break;
              case 'horizontal': titleKey = 'symmetry_horizontal'; break;
              case 'mandala': titleKey = 'symmetry_mandala'; break;
              default: titleKey = 'symmetry_off';
          }
          const title = getText(titleKey);
          btnSymmetry.setAttribute('aria-label', title);
          btnSymmetry.title = getText('tooltip_symmetry');
      }
      
      function updateSymmetryUI() { updateSymmetryButtonUI(); }
      function cycleSymmetryMode() {
          performAction(() => {
              const currentIndex = SYMMETRY_MODES.indexOf(symmetryMode);
              symmetryMode = SYMMETRY_MODES[(currentIndex + 1) % SYMMETRY_MODES.length];
              updateSymmetryUI();
          });
      }

      const pointerState = { id: null, downEl: null, downX: 0, downY: 0, longPressTimer: null, suppressClick: false, isDragging: false, dragSource: null, currentTarget: null, beforeState: null, longPressTarget: null };
      
      function applyActionToTiles(indices, actionFn) {
          const allTiles = tiles();
          indices.forEach(idx => {
              if (allTiles[idx]) {
                  actionFn(allTiles[idx]);
              }
          });
      }

      function onPointerDown(e) {
        if (isBreathing) return;
        const el = e.target.closest('.tile'); if (!el) return;
        e.preventDefault();
        el.setPointerCapture(e.pointerId);
        Object.assign(pointerState, { id: e.pointerId, downEl: el, downX: e.clientX, downY: e.clientY, suppressClick: false, isDragging: false, dragSource: null, currentTarget: null, beforeState: getCurrentState() });
        
        pointerState.longPressTimer = setTimeout(() => {
            if (pointerState.isDragging) return;
            pointerState.suppressClick = true;
            if (selectedColor || isRainbowModeActive) {
                performAction(resetSelectedColor);
            } else {
                openColorPickerModal(el);
            }
        }, LONG_PRESS_SHOW_MS);

        if (!isBrushModeOn) { 
            clearAllHighlights(); 
            el.classList.add('source-highlight'); 
            pointerState.dragSource = el; 
        }
      }

      function onPointerMove(e) {
        if (pointerState.id !== e.pointerId) return;
        if (!pointerState.isDragging) {
            const dist = Math.hypot(e.clientX - pointerState.downX, e.clientY - pointerState.downY);
            if (dist >= 8) {
                clearTimeout(pointerState.longPressTimer);
                pointerState.longPressTimer = null;
                pointerState.isDragging = true;
                pointerState.suppressClick = true;
                if (isBrushModeOn && selectedColorIndex === -1) {
                    pointerState.dragSource = pointerState.downEl;
                    clearGoldOverlay(pointerState.dragSource);
                }
            }
        }
        if (!pointerState.isDragging) return;
        const targetEl = document.elementFromPoint(e.clientX, e.clientY)?.closest('.tile');
        if (!targetEl || targetEl === pointerState.currentTarget) return;
        pointerState.currentTarget?.classList.remove('ring-4', 'ring-white', 'target-highlight');
        pointerState.currentTarget = targetEl;
        if (isBrushModeOn) {
            if (isRainbowModeActive) {
                const targetIndices = getSymmetricIndices(tiles().indexOf(targetEl));
                applyActionToTiles(targetIndices, tile => {
                    clearGoldOverlay(tile);
                    const randomIndex = Math.floor(Math.random() * paletteLen());
                    setIndex(tile, randomIndex);
                });
            } else if (selectedColorIndex !== -1) {
                const targetIndices = getSymmetricIndices(tiles().indexOf(targetEl));
                applyActionToTiles(targetIndices, tile => {
                    clearGoldOverlay(tile);
                    setIndex(tile, selectedColorIndex);
                });
            } else {
                const sourceIndex = getIndex(pointerState.dragSource);
                const targetIndices = getSymmetricIndices(tiles().indexOf(targetEl));
                applyActionToTiles(targetIndices, tile => {
                    clearGoldOverlay(tile);
                    setIndex(tile, sourceIndex);
                });
                targetEl.classList.add('ring-4', 'ring-white');
            }
        } else {
            if (targetEl !== pointerState.dragSource) {
                targetEl.classList.add('target-highlight');
            } else {
                pointerState.currentTarget = null;
            }
        }
      }

      function onPointerUp(e) {
        if (isBreathing) return;
        clearTimeout(pointerState.longPressTimer);
        const beforeState = pointerState.beforeState;
        if (pointerState.isDragging) {
            if (!isBrushModeOn && pointerState.currentTarget) {
                const sourceEl = pointerState.dragSource; 
                const targetEl = pointerState.currentTarget;
                const targetIndices = getSymmetricIndices(tiles().indexOf(targetEl));
                applyActionToTiles(targetIndices, tile => {
                    if (isGold(sourceEl)) { applyGoldOverlay(tile); } 
                    else { clearGoldOverlay(tile); setIndex(tile, getIndex(sourceEl)); }
                });
            }
        } else if (!pointerState.suppressClick && e.target.closest('.tile')) {
            const tile = e.target.closest('.tile');
            if (isRainbowModeActive) {
                const indices = getSymmetricIndices(tiles().indexOf(tile));
                applyActionToTiles(indices, el => {
                    clearGoldOverlay(el);
                    const randomIndex = Math.floor(Math.random() * paletteLen());
                    setIndex(el, randomIndex);
                });
            } else if (selectedColorIndex !== -1) {
                const indices = getSymmetricIndices(tiles().indexOf(tile));
                applyActionToTiles(indices, el => {
                    clearGoldOverlay(el);
                    setIndex(el, selectedColorIndex);
                });
            } else {
                const indices = getSymmetricIndices(tiles().indexOf(tile));
                applyActionToTiles(indices, el => {
                    clearGoldOverlay(el); 
                    setIndex(el, getIndex(el) + 1);
                });
            }
        }
        const afterState = getCurrentState();
        if (beforeState && !areStatesEqual(beforeState, afterState)) {
             pushHistory({ before: beforeState, after: afterState }); 
             hasPerformedInitialAutofill = true;
             if (isOnboarding) {
                if (onboardingStep === 1) advanceOnboarding(2);
                else if (onboardingStep === 2) advanceOnboarding(3);
                else if (onboardingStep === 3) advanceOnboarding(4);
             }
        }
        clearAllHighlights();
        pointerState.currentTarget?.classList.remove('ring-4', 'ring-white', 'target-highlight');
        Object.assign(pointerState, { id: null, downEl: null, isDragging: false, dragSource: null, currentTarget: null, beforeState: null, longPressTarget: null });
      }

      function updateLayout() {
        if (window.innerWidth < 768) { appShell.style.width = ''; return; }
        const controlsHeight = controlsContainer.offsetHeight;
        const viewportHeight = window.innerHeight;
        const topMargin = parseInt(window.getComputedStyle(appShell.parentElement).paddingTop, 10);
        const availableHeight = viewportHeight - controlsHeight - (topMargin * 2);
        const newWidth = Math.min(720, window.innerWidth * 0.85, availableHeight);
        appShell.style.width = `${newWidth}px`;
      }
      board.addEventListener('pointerdown', onPointerDown);
      board.addEventListener('pointermove', onPointerMove);
      board.addEventListener('pointerup', onPointerUp);
      board.addEventListener('pointercancel', onPointerUp);

      function setAllControlsDisabled(disabled) {
        document.querySelectorAll('.ctrl').forEach(btn => {
            if (btn.id !== 'btnBreatheModalClose') {
                btn.disabled = disabled;
            }
        });
        if (breatheModal.classList.contains('modal-visible')) {
            btnStartSoloBreathe.disabled = disabled;
            btnStartGroupBreathe.disabled = disabled;
        }
      }

      async function stopBreathingEffect() {
        btnExitBreathe.classList.remove('visible');
        const allTiles = tiles();
        const fadeOutPromises = allTiles
            .filter(tile => tile.classList.contains('breathing-tile'))
            .map(tile => {
                return new Promise(resolve => {
                    tile.addEventListener('animationiteration', () => {
                        tile.classList.remove('breathing-tile');
                        tile.style.animationDelay = '';
                        resolve();
                    }, { once: true });
                });
            });
        await Promise.all(fadeOutPromises);
        controlsContainer.style.transition = 'opacity 1.2s linear';
        controlsContainer.classList.remove('controls-hidden');
        await new Promise(resolve => setTimeout(resolve, 1200));
        setAllControlsDisabled(false);
        updateUndoRedoButtons();
        isBreathing = false;
        controlsContainer.style.transition = '';
      }

      async function startBreathingEffect(isGrouped = false) {
          if (isBreathing) return;
          isBreathing = true;
          setAllControlsDisabled(true);
          controlsContainer.style.transition = 'opacity 2s linear';
          controlsContainer.classList.add('controls-hidden');
          await new Promise(resolve => setTimeout(resolve, 2000));
          const allTiles = tiles();
          if (isGrouped) {
              const colorDelayMap = new Map();
              const uniqueColors = [...new Set(allTiles.map(tile => {
                  return isGold(tile) ? GOLD : tile.style.backgroundColor;
              }))];
              uniqueColors.forEach(color => {
                  colorDelayMap.set(color, Math.random() * 3);
              });
              allTiles.forEach(tile => {
                  const colorKey = isGold(tile) ? GOLD : tile.style.backgroundColor;
                  const delay = colorDelayMap.get(colorKey);
                  tile.style.animationDelay = `${delay}s`;
                  tile.classList.add('breathing-tile');
              });
          } else {
              allTiles.forEach(tile => {
                  tile.style.animationDelay = `${Math.random() * 3}s`;
                  tile.classList.add('breathing-tile');
              });
          }
          setTimeout(() => {
            if (isBreathing) {
              btnExitBreathe.classList.add('visible');
            }
          }, 4000);
          const exitHandler = () => { stopBreathingEffect(); };
          appContainer.addEventListener('pointerdown', exitHandler, { once: true });
      }

      function openBreatheModal() {
        if (isBreathing) return;
        setAllControlsDisabled(true); 
        breatheModal.classList.add('modal-visible');
      }

      function closeBreatheModal() {
        breatheModal.classList.remove('modal-visible');
        setAllControlsDisabled(false);
        updateUndoRedoButtons(); 
      }

      function openResizeModal() {
        if (isBreathing) return;
        resizeInput.value = n; 
        resizeModal.classList.add('modal-visible');
        resizeInput.focus();
        resizeInput.select();
    }

    function closeResizeModal() {
        resizeModal.classList.remove('modal-visible');
    }

    function handleConfirmResize() {
        let newSize = parseInt(resizeInput.value, 10);
        if (isNaN(newSize) || newSize < 1 || newSize > 50) {
            resizeInput.style.borderColor = 'red';
            setTimeout(() => { resizeInput.style.borderColor = ''; }, 1000);
            return;
        }
        closeResizeModal();
        if (newSize !== n) {
             animateBoardTransition(() => performAction(() => _performResize(newSize)));
        }
    }

    function createRainbowIconSVG(currentPalette) {
        const p = currentPalette || palette();
        const c1 = p[0] || '#FFD700';
        const c2 = p[Math.floor(p.length / 4)] || '#42A5F5';
        const c3 = p[Math.floor(p.length / 2)] || '#F44336';
        const c4 = p[Math.floor(p.length * 3 / 4)] || '#66BB6A';
        return `<svg viewBox="0 0 24 24" fill="none" stroke="none" style="width: var(--icon-size); height: var(--icon-size);">
            <rect x="4" y="4" width="8" height="8" fill="${c1}" rx="1"/>
            <rect x="12" y="4" width="8" height="8" fill="${c2}" rx="1"/>
            <rect x="4" y="12" width="8" height="8" fill="${c3}" rx="1"/>
            <rect x="12" y="12" width="8" height="8" fill="${c4}" rx="1"/>
        </svg>`;
    }
    
    function updateGlowEffect() {
        if (isRainbowModeActive) {
            board.classList.add('glowing-border-rainbow');
            board.classList.remove('glowing-border');
        } else if (selectedColor) {
            root.style.setProperty('--glow-color', selectedColor);
            board.classList.add('glowing-border');
            board.classList.remove('glowing-border-rainbow');
        } else {
            board.classList.remove('glowing-border', 'glowing-border-rainbow');
        }
    }

    function updateColorPickerButtonUI() {
        if (!btnColorPicker.querySelector('circle') && !isRainbowModeActive) {
            btnColorPicker.innerHTML = originalColorPickerIconHTML;
        }
        const colorPickerIconCircle = btnColorPicker.querySelector('svg circle');
        if (isRainbowModeActive) {
            btnColorPicker.innerHTML = createRainbowIconSVG();
        } else if (selectedColor) {
            if(colorPickerIconCircle) {
                colorPickerIconCircle.style.fill = selectedColor;
                colorPickerIconCircle.style.stroke = selectedColor === '#000000' ? '#424242' : selectedColor;
            }
        } else {
             if(colorPickerIconCircle) {
                colorPickerIconCircle.style.fill = '#000';
                colorPickerIconCircle.style.stroke = '#fff';
             }
        }
    }

      function selectColorAndClose(color) {
        const targetTile = pointerState.longPressTarget;
        isRainbowModeActive = false;
        selectedColor = color;
        selectedColorIndex = palette().indexOf(color);
        updateGlowEffect();
        updateColorPickerButtonUI();
        if (targetTile) {
            performAction(() => {
                const targetIndices = getSymmetricIndices(tiles().indexOf(targetTile));
                applyActionToTiles(targetIndices, tile => {
                    clearGoldOverlay(tile);
                    setIndex(tile, selectedColorIndex);
                });
            });
        }
        closeColorPickerModal();
      }

      function selectRainbowAndClose() {
        const targetTile = pointerState.longPressTarget;
        isRainbowModeActive = true;
        selectedColor = null;
        selectedColorIndex = -1;
        updateGlowEffect();
        updateColorPickerButtonUI();
        if (targetTile) {
            performAction(() => {
                const targetIndices = getSymmetricIndices(tiles().indexOf(targetTile));
                applyActionToTiles(targetIndices, tile => {
                    clearGoldOverlay(tile);
                    const randomIndex = Math.floor(Math.random() * paletteLen());
                    setIndex(tile, randomIndex);
                });
            });
        }
        closeColorPickerModal();
    }

      function renderColorPickerContent() {
          const currentPalette = PALETTES[activePaletteIndex];
          const colors = currentPalette.colors;
          const totalPages = Math.ceil(colors.length / COLORS_PER_PAGE);
          
          if (colorPickerPage >= totalPages) {
              colorPickerPage = 0;
          }

          if (totalPages > 1) {
            colorPickerHeader.style.display = 'flex';
          } else {
            colorPickerHeader.style.display = 'none';
          }

          const displayIcon = currentPalette.iconHTML || currentPalette.emoji || '';
          colorPickerPaletteName.innerHTML = displayIcon;
          
          colorPickerSwatches.innerHTML = '';
          const frag = document.createDocumentFragment();

          const rainbowSwatch = document.createElement('div');
          rainbowSwatch.className = 'color-swatch';
          const rainbowSwatchInner = document.createElement('div');
          rainbowSwatchInner.className = 'color-swatch-inner';
          rainbowSwatchInner.innerHTML = createRainbowIconSVG();
          rainbowSwatch.appendChild(rainbowSwatchInner);
          rainbowSwatch.setAttribute('aria-label', getText('colorPicker_rainbow'));
          rainbowSwatch.addEventListener('click', () => selectRainbowAndClose());
          frag.appendChild(rainbowSwatch);

          const startIndex = colorPickerPage * COLORS_PER_PAGE;
          const endIndex = startIndex + COLORS_PER_PAGE;
          const pageColors = colors.slice(startIndex, endIndex);

          pageColors.forEach((color) => {
              const swatch = document.createElement('div');
              swatch.className = 'color-swatch';
              const swatchInner = document.createElement('div');
              swatchInner.className = 'color-swatch-inner';
              swatchInner.style.backgroundColor = color;
              swatch.appendChild(swatchInner);
              swatch.dataset.color = color;
              swatch.setAttribute('aria-label', `${getText('colorPicker_select')} ${color}`);
              swatch.addEventListener('click', () => selectColorAndClose(color));
              frag.appendChild(swatch);
          });
          
          const placeholdersNeeded = (COLORS_PER_PAGE + 1) - (pageColors.length + 1);
          for (let i = 0; i < placeholdersNeeded; i++) {
              const placeholder = document.createElement('div');
              placeholder.className = 'color-swatch';
              placeholder.style.pointerEvents = 'none';
              placeholder.style.opacity = '0';
              frag.appendChild(placeholder);
          }

          colorPickerSwatches.appendChild(frag);

          colorPickerPagination.innerHTML = '';
          if (totalPages > 1) {
              for (let i = 0; i < totalPages; i++) {
                  const dot = document.createElement('div');
                  dot.className = 'pagination-dot' + (i === colorPickerPage ? ' active' : '');
                  dot.dataset.page = i;
                  dot.addEventListener('click', (e) => {
                      colorPickerPage = parseInt(e.target.dataset.page, 10);
                      renderColorPickerContent();
                  });
                  colorPickerPagination.appendChild(dot);
              }
          }
      }

      function openColorPickerModal(targetTile = null) {
          if (isBreathing) return;
          pointerState.longPressTarget = targetTile;
          colorPickerPage = 0;
          renderColorPickerContent();
          colorPickerModal.classList.add('modal-visible');
      }

      function closeColorPickerModal() {
          colorPickerModal.classList.remove('modal-visible');
          pointerState.longPressTarget = null;
      }
      
      function openHelpModal() { 
        populateHelpModal();
        helpModal.classList.add('modal-visible'); 
      }
      function closeHelpModal() { helpModal.classList.remove('modal-visible'); }

      function handleCtrlClick(e, actionFn) {
        if (isBreathing) return;
        if (wasLongPress) {
          wasLongPress = false;
          return;
        }
        actionFn();
        // Onboarding: Any button click advances from step 3 to 4
        if (isOnboarding && onboardingStep === 3) {
            advanceOnboarding(4);
        }
      }

      function handleColorPickerClick() {
        if (selectedColor || isRainbowModeActive) {
            performAction(resetSelectedColor);
        } else {
            openColorPickerModal();
        }
      }

      function navigateColorPages(isNext) {
        const totalPages = Math.ceil(PALETTES[activePaletteIndex].colors.length / COLORS_PER_PAGE);
        if(totalPages <= 1) return;
        if(isNext) {
          colorPickerPage = (colorPickerPage + 1) % totalPages;
        } else {
          colorPickerPage = (colorPickerPage - 1 + totalPages) % totalPages;
        }
        renderColorPickerContent();
      }
      
      let lastWheelTime = 0; let touchStartX = 0; let touchEndX = 0;
      function handlePaletteWheel(e) { if (Date.now() - lastWheelTime < 200) return; e.preventDefault(); navigateColorPages(e.deltaY > 0); lastWheelTime = Date.now(); }
      function handleTouchStart(e) { touchStartX = e.changedTouches[0].screenX; }
      function handleTouchEnd(e) { touchEndX = e.changedTouches[0].screenX; handleSwipeGesture(); }
      function handleSwipeGesture() { if (touchEndX < touchStartX - 50) { navigateColorPages(true); } if (touchEndX > touchStartX + 50) { navigateColorPages(false); } }
      
      async function handleSaveImage() {
        if (!generatedImageFile) return;
        const isMobile = navigator.share && navigator.canShare;
        const fileToSave = new File([generatedImageFile], getSanitizedFileName('png'), { type: generatedImageFile.type });
        if (isMobile) { try { await navigator.share({ files: [fileToSave], title: 'Followed my intuition' }); } catch (err) { if (err.name !== 'AbortError') { console.error('Share API error:', err); } } } else { const link = document.createElement('a'); link.href = URL.createObjectURL(fileToSave); link.download = fileToSave.name; link.click(); URL.revokeObjectURL(link.href); }
        closeModal();
      }
      async function handleSaveProject() {
          const state = getCurrentState();
          const stateString = JSON.stringify(state, null, 2);
          const blob = new Blob([stateString], { type: 'application/json' });
          const fileName = getSanitizedFileName('json');
          const projectFile = new File([blob], fileName, { type: 'application/json' });
          const isMobile = navigator.share && navigator.canShare;
          if (isMobile) { try { await navigator.share({ files: [projectFile], title: 'My Idea' }); } catch (err) { if (err.name !== 'AbortError') { console.error('Share API error:', err); } } } else { const link = document.createElement('a'); link.href = URL.createObjectURL(projectFile); link.download = fileName; link.click(); URL.revokeObjectURL(link.href); }
          closeModal();
      }
      function handleLoadProject() { projectFileInput.click(); closeModal(); }
      function onProjectFileSelected(event) {
        const file = event.target.files[0]; if (!file) return;
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            const state = JSON.parse(e.target.result);
            if (state.n && state.tiles && typeof state.activePaletteIndex !== 'undefined') { animateBoardTransition(() => { applyState(state); history = []; future = []; updateUndoRedoButtons(); }); } 
            else { alert(getText('error_invalidFile')); }
          } catch (error) { console.error("Failed to load or parse project file:", error); alert(getText('error_readFile')); }
        };
        reader.readAsText(file);
        event.target.value = null;
      }
      
      function hideLongPressDisplay() {
          clearTimeout(longPressTimer);
          longPressOverlay.classList.remove('visible');
          longPressDisplay.classList.remove('visible');
          setTimeout(() => { longPressDisplay.innerHTML = ''; }, 250);
      }
      function handlePointerDownCtrl(e) {
          if (isBreathing) return;
          const btn = e.currentTarget;
          longPressTimer = setTimeout(() => {
              wasLongPress = true;
              if (btn.id === 'btnResizeUp' || btn.id === 'btnResizeDown') {
                  openResizeModal();
                  return; 
              }
              if (btn.id === 'btnBrushMode') {
                  const customHTML = `<div class="flex flex-col items-center justify-center gap-4 text-lg text-gray-300"><div class="flex items-center gap-4"><svg viewBox="0 0 24 24" style="width: var(--icon-size); height: var(--icon-size);"><path d="M12 2 L2 22 L22 22 Z" stroke="#fff" stroke-width="2" fill="#fff" /></svg><span>${getText('brushMode_paint')}</span></div><div class="flex items-center gap-4"><svg viewBox="0 0 24 24" style="width: var(--icon-size); height: var(--icon-size);"><path d="M12 2 L2 22 L22 22 Z" stroke="#fff" stroke-width="2" fill="#000" /></svg><span>${getText('brushMode_copy')}</span></div></div>`;
                  longPressDisplay.innerHTML = customHTML;
              } else {
                  let iconElement;
                  if (btn.classList.contains('palette')) { iconElement = btn.cloneNode(true); iconElement.style.background = 'transparent'; iconElement.style.border = 'none'; } 
                  else { iconElement = btn.querySelector('.glyph, svg, .glyph-save, .glyph-reset, .glyph-special-reset, .glyph-dark'); }
                  if (!iconElement) return;
                  const clonedIcon = iconElement.cloneNode(true);
                  const baseIconSize = parseInt(getComputedStyle(root).getPropertyValue('--icon-size'));
                  const targetIconSize = baseIconSize * 2;
                  if (btn.classList.contains('palette')) { clonedIcon.style.fontSize = `${targetIconSize}px`; } 
                  else { clonedIcon.style.width = `${targetIconSize}px`; clonedIcon.style.height = `${targetIconSize}px`; }
                  const textElement = document.createElement('p');
                  if (btn.id === 'btnPalette') { textElement.innerHTML = `${activePaletteIndex === 0 ? getText('palette_journey') : PALETTES[activePaletteIndex].name}`; } 
                  else if (btn.id === 'btnSymmetry') { 
                    let key;
                    if (symmetryMode === 'vertical') key = 'symmetry_vertical';
                    else if (symmetryMode === 'horizontal') key = 'symmetry_horizontal';
                    else if (symmetryMode === 'mandala') key = 'symmetry_mandala';
                    else key = 'symmetry_off';
                    textElement.innerHTML = getText(key); 
                  }
                  else { textElement.innerHTML = btn.title || ""; }
                  textElement.className = 'text-lg text-gray-300 text-center px-4';
                  longPressDisplay.innerHTML = '';
                  longPressDisplay.appendChild(clonedIcon);
                  longPressDisplay.appendChild(textElement);
              }
              longPressOverlay.classList.add('visible');
              longPressDisplay.classList.add('visible');
          }, LONG_PRESS_SHOW_MS);
      }
      
      function populateHelpModal() {
        const contentDiv = document.getElementById('helpModalContent');
        contentDiv.innerHTML = '';
        
        const categories = {
            inspiration: {
                titleKey: 'help_category_inspiration',
                buttons: ['btnPalette', 'btnRandom', 'btnInvert', 'btnSpecialReset', 'btnDark']
            },
            order: {
                titleKey: 'help_category_order',
                buttons: ['btnResizeUp', 'btnResizeDown', 'btnGap', 'btnResetBoard']
            },
            touch: {
                titleKey: 'help_category_touch',
                buttons: ['btnBrushMode', 'btnSymmetry', 'btnColorPicker']
            },
            expression: {
                titleKey: 'help_category_expression',
                buttons: ['btnSave', 'btnShowBreatheMenu']
            },
            tools: {
                titleKey: 'help_category_tools',
                buttons: ['btnUndo', 'btnRedo']
            }
        };

        const helpData = {
          'btnInvert': getText('help_invert'), 'btnPalette': getText('help_palette'), 'btnRandom': getText('help_random'),
          'btnColorPicker': getText('help_colorPicker'), 'btnSymmetry': getText('help_symmetry'), 'btnBrushMode': getText('help_brushMode'),
          'btnRedo': getText('help_redo'), 'btnUndo': getText('help_undo'), 'btnDark': getText('help_dark'),
          'btnSpecialReset': getText('help_specialReset'), 'btnResetBoard': getText('help_resetBoard'),
          'btnResizeUp': getText('help_resizeUp'), 'btnResizeDown': getText('help_resizeDown'), 'btnGap': getText('help_gap'),
          'btnSave': getText('help_save'), 'btnShowBreatheMenu': getText('help_breathe')
        };

        for (const categoryKey in categories) {
            const category = categories[categoryKey];
            
            const titleEl = document.createElement('h3');
            titleEl.className = 'help-category-title';
            titleEl.textContent = getText(category.titleKey);
            contentDiv.appendChild(titleEl);

            category.buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (!btn || !helpData[btnId]) return;

                const helpItem = document.createElement('div');
                helpItem.className = 'flex items-center gap-4';

                const iconWrapper = document.createElement('div');
                iconWrapper.className = 'help-item-icon-wrapper';
                iconWrapper.innerHTML = btn.innerHTML;

                const svg = iconWrapper.querySelector('svg');
                if (svg && (btnId === 'btnBrushMode' || btnId === 'btnGap' || btnId === 'btnResizeUp' || btnId === 'btnResizeDown' || btnId === 'btnShowBreatheMenu')) {
                    svg.style.width = 'var(--side-icon-size)';
                    svg.style.height = 'var(--side-icon-size)';
                }
                
                if (btn.id === 'btnSymmetry') {
                    const originalPaths = btn.querySelectorAll('.part');
                    const clonedPaths = iconWrapper.querySelectorAll('.part');
                    originalPaths.forEach((part, index) => {
                        if (clonedPaths[index]) {
                            clonedPaths[index].style.stroke = part.style.stroke;
                        }
                    });
                }
                if (btn.id === 'btnBrushMode') {
                    const path = iconWrapper.querySelector('svg path');
                    if (path) {
                        path.setAttribute('fill', isBrushModeOn ? '#fff' : '#000');
                    }
                }

                const textWrapper = document.createElement('div');
                textWrapper.textContent = helpData[btnId];
                textWrapper.className = 'text-gray-300 text-sm';
                
                helpItem.appendChild(iconWrapper);
                helpItem.appendChild(textWrapper);
                contentDiv.appendChild(helpItem);
            });
        }
      }

      function setTextContent() {
        const splashTextEl = document.getElementById('splashText');
        if (splashTextEl) splashTextEl.textContent = getText('splashTitle');
        const fileNameLabelEl = document.getElementById('fileNameLabel');
        if (fileNameLabelEl) fileNameLabelEl.textContent = getText('saveModal_feelsLike');
        if (fileNameInput) fileNameInput.placeholder = getText('saveModal_defaultFilename');
        if (btnModalClose) btnModalClose.title = getText('saveModal_close');
        if (btnSaveImage) btnSaveImage.title = getText('saveModal_saveImage');
        if (btnSaveProjectIdea) btnSaveProjectIdea.title = getText('saveModal_saveIdea');
        if (btnLoadProjectIdea) btnLoadProjectIdea.title = getText('saveModal_loadIdea');
        const breatheSoloLabelEl = document.getElementById('breatheSoloLabel');
        if (breatheSoloLabelEl) breatheSoloLabelEl.textContent = getText('breatheModal_solo');
        const breatheGroupLabelEl = document.getElementById('breatheGroupLabel');
        if (breatheGroupLabelEl) breatheGroupLabelEl.textContent = getText('breatheModal_group');
        const resizeModalTitleEl = document.getElementById('resizeModalTitle');
        if (resizeModalTitleEl) resizeModalTitleEl.textContent = getText('resizeModal_title');
        const resizeModalPromptEl = document.getElementById('resizeModalPrompt');
        if (resizeModalPromptEl) resizeModalPromptEl.textContent = getText('resizeModal_prompt');
        if (btnConfirmResize) btnConfirmResize.textContent = getText('resizeModal_confirm');
        const helpModalTitleEl = document.getElementById('helpModalTitle');
        if (helpModalTitleEl) helpModalTitleEl.textContent = getText('help_title');
        const helpIntroTextEl = document.getElementById('helpIntroText');
        if (helpIntroTextEl) helpIntroTextEl.textContent = getText('help_intro');
        if(btnInvert) btnInvert.title = getText('tooltip_invert');
        if(btnRandom) btnRandom.title = getText('tooltip_random');
        if(btnColorPicker) btnColorPicker.title = getText('tooltip_colorPicker');
        if(btnSymmetry) btnSymmetry.title = getText('tooltip_symmetry');
        if(btnRedo) btnRedo.title = getText('tooltip_redo');
        if(btnUndo) btnUndo.title = getText('tooltip_undo');
        if(btnDark) btnDark.title = getText('tooltip_dark');
        if(btnSpecialReset) btnSpecialReset.title = getText('tooltip_specialReset');
        if(btnResetBoard) btnResetBoard.title = getText('tooltip_resetBoard');
        if(btnResizeUp) btnResizeUp.title = getText('tooltip_resizeUp');
        if(btnResizeDown) btnResizeDown.title = getText('tooltip_resizeDown');
        if(btnSave) btnSave.title = getText('tooltip_save');
        if(btnShowBreatheMenu) btnShowBreatheMenu.title = getText('tooltip_breathe');
        if(btnTutorial) btnTutorial.title = getText('tooltip_tutorial');
        if(btnLangToggle) btnLangToggle.textContent = currentLang.toUpperCase();
        
        const allButtonsForAria = document.querySelectorAll('.ctrl');
        allButtonsForAria.forEach(btn => {
            if (btn.title) {
              btn.setAttribute('aria-label', btn.title)
            }
        });
      }
      
      // ---- Language Switching Logic ----
      function changeLanguage(lang) {
        currentLang = lang;

        const helpModalInnerContainer = document.getElementById('helpModalInnerContainer');
        if (lang === 'he') {
            helpModalInnerContainer.classList.add('rtl-mode');
        } else {
            helpModalInnerContainer.classList.remove('rtl-mode');
        }

        PALETTES.forEach(p => {
          const key = Object.keys(translations).find(k => translations[k].en === p.originalName);
          if (key && translations[key][currentLang]) {
            p.name = getText(key);
          } else {
            p.name = p.originalName;
          }
        });

        setTextContent();
        
        updatePaletteHeader();

        if (helpModal.classList.contains('modal-visible')) {
            populateHelpModal();
        }

        try {
          localStorage.setItem('userLanguage', lang);
        } catch (e) {
          console.warn('Could not save language to localStorage.');
        }
      }

      function toggleLanguage() {
        const currentIndex = availableLangs.indexOf(currentLang);
        const nextIndex = (currentIndex + 1) % availableLangs.length;
        const newLang = availableLangs[nextIndex];
        changeLanguage(newLang);
      }
      
      // ---- Onboarding Logic ----
      function updateOnboardingUI() {
        const allControls = document.querySelectorAll('.ctrl');

        // Define controls for each stage
        const stage1Controls = [btnPalette, btnSpecialReset];
        const stage2Controls = [...stage1Controls, btnUndo, btnRedo];
        const stage3Controls = [...stage2Controls, btnSymmetry, btnResizeUp, btnResizeDown, btnShowBreatheMenu, btnDark];

        // Hide all controls initially if onboarding is active
        if (onboardingStep > 0) {
            allControls.forEach(btn => {
                btn.classList.remove('onboarding-visible');
                btn.classList.add('onboarding-hidden');
            });
        }

        // Function to make a set of controls visible
        const showControls = (controls) => {
            setTimeout(() => {
                controls.forEach(btn => {
                    btn.classList.remove('onboarding-hidden');
                    btn.classList.add('onboarding-visible');
                });
            }, 50);
        };

        if (onboardingStep === 1) {
            showControls(stage1Controls);
        } else if (onboardingStep === 2) {
            showControls(stage2Controls);
        } else if (onboardingStep === 3) {
            showControls(stage3Controls);
        } else if (onboardingStep >= 4) {
            // Show all controls
            allControls.forEach(btn => {
                btn.classList.remove('onboarding-hidden');
                btn.classList.add('onboarding-visible');
            });
            // Nudge the tutorial button
            btnTutorial.classList.add('glow-animation');
            setTimeout(() => {
                btnTutorial.classList.remove('glow-animation');
            }, 4000); // Let it glow for 4 seconds
        }
      }
      
      function advanceOnboarding(step) {
          if (!isOnboarding || step <= onboardingStep) return;

          onboardingStep = step;
          updateOnboardingUI();

          if (onboardingStep >= 4) {
              isOnboarding = false;
              try {
                  localStorage.setItem(ONBOARDING_STORAGE_KEY, 'true');
              } catch (e) {
                  console.warn('Could not save onboarding status to localStorage.');
              }
          }
      }

      function startOnboarding() {
          isOnboarding = true;
          onboardingStep = 1;
          updateOnboardingUI();
      }

      async function initializeApp() {
        const splashScreen = document.getElementById('splashScreen');
        const splashText = document.getElementById('splashText');
        
        try {
            const savedLang = localStorage.getItem('userLanguage');
            if (savedLang && availableLangs.includes(savedLang)) {
                currentLang = savedLang;
            }
        } catch(e) {
            console.warn('Could not read language from localStorage.');
        }

        changeLanguage(currentLang);

        buildBoard(n, false); 
        fillRandom(); // MODIFIED: Start with a random board instead of the initial pattern
        hasPerformedInitialAutofill = true;
        
        applySeparator();
        updateUndoRedoButtons();
        setBrushMode(true);
        updateSymmetryUI();
        updateColorPickerButtonUI();
        updateGlowEffect();
        updateLayout();
        
        // ---- Onboarding Debug Button ----
        const helpModalContent = document.getElementById('helpModalContent');
        const btnResetOnboarding = document.createElement('button');
        btnResetOnboarding.id = 'btnResetOnboarding';
        helpModalContent.parentNode.appendChild(btnResetOnboarding); // Append to the container of the content
        btnResetOnboarding.addEventListener('click', () => {
            try {
                localStorage.removeItem(ONBOARDING_STORAGE_KEY);
                location.reload();
            } catch (e) {
                console.error('Failed to reset onboarding', e);
            }
        });

        // ---- Event Listeners ----
        btnRandom.addEventListener('click', (e) => handleCtrlClick(e, randomizeAll));
        btnInvert.addEventListener('click', (e) => handleCtrlClick(e, invertGrid));
        btnPalette.addEventListener('click', (e) => handleCtrlClick(e, () => {
          switchPalette();
          if (isOnboarding) {
            if (onboardingStep === 1) advanceOnboarding(2);
            else if (onboardingStep === 2) advanceOnboarding(3);
          }
        }));
        btnResetBoard.addEventListener('click', (e) => handleCtrlClick(e, () => animateBoardTransition(resetToGoldAndDefaultPalette)));
        btnSpecialReset.addEventListener('click', (e) => handleCtrlClick(e, () => {
          animateBoardTransition(() => {
            performAction(specialReset);
            if (isOnboarding && onboardingStep === 1) advanceOnboarding(2);
          });
        }));
        btnResizeUp.addEventListener('click', (e) => handleCtrlClick(e, () => resizeGrid(true)));
        btnResizeDown.addEventListener('click', (e) => handleCtrlClick(e, () => resizeGrid(false)));
        btnSave.addEventListener('click', (e) => handleCtrlClick(e, savePNG));
        btnGap.addEventListener('click', (e) => handleCtrlClick(e, cycleSeparator));
        btnBrushMode.addEventListener('click', (e) => handleCtrlClick(e, toggleBrushMode));
        btnUndo.addEventListener('click', (e) => handleCtrlClick(e, undo));
        btnRedo.addEventListener('click', (e) => handleCtrlClick(e, redo));
        btnTutorial.addEventListener('click', (e) => handleCtrlClick(e, openHelpModal));
        btnSymmetry.addEventListener('click', (e) => handleCtrlClick(e, cycleSymmetryMode));
        btnShowBreatheMenu.addEventListener('click', (e) => handleCtrlClick(e, openBreatheModal));
        btnColorPicker.addEventListener('click', (e) => handleCtrlClick(e, handleColorPickerClick));
        btnDark.addEventListener('click', (e) => handleCtrlClick(e, goDarkAction));
        btnModalClose.addEventListener('click', closeModal);
        saveModal.addEventListener('click', (e) => { if (e.target === saveModal) { closeModal(); } });
        btnBreatheModalClose.addEventListener('click', closeBreatheModal);
        breatheModal.addEventListener('click', (e) => { if (e.target === breatheModal) { closeBreatheModal(); } });
        btnStartSoloBreathe.addEventListener('click', () => { closeBreatheModal(); startBreathingEffect(false); });
        btnStartGroupBreathe.addEventListener('click', () => { closeBreatheModal(); startBreathingEffect(true); });
        colorPickerModal.addEventListener('click', (e) => { if (e.target === colorPickerModal) { closeColorPickerModal(); } });
        btnHelpModalClose.addEventListener('click', closeHelpModal);
        helpModal.addEventListener('click', (e) => { if (e.target === helpModal) { closeHelpModal(); } });
        btnNextPalette.addEventListener('click', () => navigateColorPages(true));
        btnPrevPalette.addEventListener('click', () => navigateColorPages(false));
        btnConfirmResize.addEventListener('click', handleConfirmResize);
        resizeInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') { handleConfirmResize(); } });
        btnResizeModalClose.addEventListener('click', closeResizeModal);
        resizeModal.addEventListener('click', (e) => { if (e.target === resizeModal) { closeResizeModal(); } });
        colorPickerModal.addEventListener('wheel', handlePaletteWheel);
        colorPickerModal.addEventListener('touchstart', handleTouchStart, { passive: true });
        colorPickerModal.addEventListener('touchend', handleTouchEnd, { passive: true });
        btnSaveImage.addEventListener('click', handleSaveImage);
        btnSaveProjectIdea.addEventListener('click', handleSaveProject);
        btnLoadProjectIdea.addEventListener('click', handleLoadProject);
        projectFileInput.addEventListener('change', onProjectFileSelected);
        document.querySelectorAll('.ctrl').forEach(btn => {
            btn.addEventListener('pointerdown', handlePointerDownCtrl);
            btn.addEventListener('pointerup', hideLongPressDisplay);
            btn.addEventListener('pointerleave', hideLongPressDisplay);
        });
        btnLangToggle.addEventListener('click', toggleLanguage);
        window.addEventListener('resize', updateLayout);
        window.addEventListener('contextmenu', e => e.preventDefault());

        // --- START: Keyboard Shortcuts ---
        window.addEventListener('keydown', (e) => {
            // Do not trigger shortcuts if a modal is open, or if typing in an input field.
            if (document.querySelector('.modal-visible') || e.target.tagName === 'INPUT') {
                return;
            }

            const isCtrlOrCmd = e.ctrlKey || e.metaKey;

            if (isCtrlOrCmd && e.key.toLowerCase() === 'z') {
                e.preventDefault();
                if (e.shiftKey) {
                    redo();
                } else {
                    undo();
                }
            } else if (isCtrlOrCmd && e.key.toLowerCase() === 'y') {
                e.preventDefault();
                redo();
            } else if (isCtrlOrCmd && e.key.toLowerCase() === 's') {
                e.preventDefault();
                savePNG();
            } else {
                // Single-key shortcuts
                switch (e.key.toLowerCase()) {
                    case 'i': invertGrid(); break;
                    case 'r': randomizeAll(); break;
                    case 'd': goDarkAction(); break;
                    case 'b': toggleBrushMode(); break;
                    case 'm': cycleSymmetryMode(); break;
                    case 'g': cycleSeparator(); break;
                    case 'arrowright':
                    case 'pagedown':
                        switchPalette(false); // Next palette
                        break;
                    case 'arrowleft':
                    case 'pageup':
                        switchPalette(true); // Previous palette
                        break;
                    case '+':
                    case '=': // The '+' key is often Shift + '='
                        resizeGrid(true);
                        break;
                    case '-':
                        resizeGrid(false);
                        break;
                }
            }
        });
        // --- END: Keyboard Shortcuts ---


        // --- Splash Screen & Onboarding ---
        let hasCompletedOnboarding = true;
        try {
            hasCompletedOnboarding = localStorage.getItem(ONBOARDING_STORAGE_KEY) === 'true';
        } catch (e) {
            console.warn('Could not read onboarding status from localStorage.');
        }

        if (!hasCompletedOnboarding) {
          document.querySelectorAll('.ctrl').forEach(c => c.classList.add('onboarding-hidden'));
          startOnboarding();
        }

        splashText.style.animation = 'fadeInText 2.5s linear forwards';
        await new Promise(r => setTimeout(r, 5000));
        splashText.style.animation = 'fadeOutText 1.5s linear forwards';
        await new Promise(r => setTimeout(r, 1500));
        const focusButton = document.getElementById('btnSpecialReset');
        focusButton.classList.add('splash-tutorial-focus');
        splashText.style.display = 'none';
        await new Promise(r => setTimeout(r, 1500)); 
        splashScreen.style.opacity = '0';
        await new Promise(r => setTimeout(r, 2000));
        splashScreen.remove();
        focusButton.classList.remove('splash-tutorial-focus');
      }

      initializeApp();

    })();
  </script>
</body>
</html>

