<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
  <title>Color Grid App</title>

  <meta property="og:type" content="website">
  <meta property="og:url" content="https://tomerrrr-create.github.io/color-grid-app/">
  <meta property="og:title" content="Follow Your Intuition">
  <meta property="og:description" content="----------------">
  <meta property="og:image" content="https://raw.githubusercontent.com/tomerrrr-create/color-grid-app/refs/heads/main/og.PNG">
  <meta property="og:locale" content="he_IL" />

  <meta name="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://tomerrrr-create.github.io/color-grid-app/">
  <meta name="twitter:title" content="Follow Your Intuition">
  <meta name="twitter:description" content="----------------">
  <meta name="twitter:image" content="https://raw.githubusercontent.com/tomerrrr-create/color-grid-app/refs/heads/main/og.PNG">
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <style>
    /* Custom properties for dynamic styling controlled by JS */
    :root {
      --grid-size: 8;
      --gap-px: 3px;
      --tile-radius: 2px;
      --icon-size: 26px;
      --save-dot-size: 10px;
      --reset-dot-size: 8px; 
      --stroke: 3px;
      --gold: #FFD700;
    }
    body {
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none; /* Safari */
      -ms-user-select: none; /* IE 10+ */
      user-select: none; /* Standard syntax */
    }
    .board {
      display: grid;
      grid-template-columns: repeat(var(--grid-size), 1fr);
      gap: var(--gap-px);
      border-width: var(--gap-px);
      border-radius: 6px;
      transition: gap 0.3s ease-in-out;
    }
    .tile {
      border-radius: var(--tile-radius);
      transition: background-color 0.4s ease, box-shadow 0.2s ease, border-radius 0.6s ease-in-out;
    }
    
    /* --- CONTROL BUTTON STYLES --- */
    #controls {
      display: grid;
      grid-template-columns: repeat(3, 50px);
      grid-template-rows: repeat(3, 50px);
      column-gap: 12px;
      row-gap: 8px;
    }
    .side-controls {
      display: grid;
      grid-template-columns: 50px;
      grid-template-rows: repeat(3, 50px);
      row-gap: 8px; /* Match main controls */
    }

    #controlsContainer {
        position: relative;
    }
    
    #controlsContainer.controls-hidden {
        opacity: 0;
        pointer-events: none;
    }

    .ctrl {
      width: 50px;
      height: 50px;
      cursor: pointer;
      outline: none;
      background: transparent;
      border: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      position: relative;
      touch-action: manipulation;
      transition: opacity 0.2s ease-in-out, transform 150ms ease-out;
    }
    .ctrl * {
      pointer-events: none;
    }
    .ctrl:focus-visible {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.25);
      border-radius: 8px;
    }
    @media (hover: hover) {
      .ctrl:hover {
        box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.25);
        border-radius: 8px;
      }
    }
    .ctrl:disabled {
        opacity: 0.3;
        cursor: not-allowed;
        box-shadow: none;
    }
    .glyph {
      width: var(--icon-size);
      height: var(--icon-size);
      display: inline-block;
      position: relative;
    }
    .ctrl svg {
        width: var(--icon-size);
        height: var(--icon-size);
    }
    .glyph-square-gold {
      background: #000;
      border: 2px solid var(--gold);
      box-sizing: border-box;
      border-radius: 2px;
    }
    .glyph-square-white {
      background: #000;
      border: 2px solid #fff;
      box-sizing: border-box;
      border-radius: 2px;
    }
    .glyph-random {
      background: linear-gradient(90deg, #000 50%, #fff 50%);
      border-radius: 50%;
    }
    .glyph-remix {
      background: linear-gradient(90deg, #fff 50%, #000 50%);
      border-radius: 50%;
    }
    .palette {
      font-size: var(--icon-size);
      line-height: 1;
    }
    
    .glyph-save, .glyph-reset, .glyph-special-reset, .glyph-tutorial {
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
    }
    .glyph-save::after, .glyph-tutorial::after {
      content: '';
      width: var(--save-dot-size);
      height: var(--save-dot-size);
      border-radius: 50%;
    }
    .glyph-save::after {
      background: #fff;
    }
    .glyph-tutorial::after {
      background: var(--gold);
      transition: background-color 0.3s ease-in-out;
    }
    .glyph-tutorial.viewed::after {
      background: #424242;
    }

    .glyph-reset::after {
      content: '';
      width: var(--reset-dot-size);
      height: var(--reset-dot-size);
      background: #fff;
      border-radius: 50%;
    }

    .glyph-special-reset {
        width: 8px;
        height: 8px;
        background-color: #424242;
        border-radius: 50%;
    }

    #btnBrushMode svg path {
        transition: fill 0.2s ease-in-out;
    }
    #btnBrushMode.brush-on svg path {
        fill: #fff;
    }
    .tile.source-highlight {
        box-shadow: 0 0 0 4px var(--gold) inset;
    }
    .tile.target-highlight {
        box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.8) inset;
    }
    .app-shell {
      width: min(85vmin, 720px);
    }
    #boardOverlay {
        transition: opacity 350ms ease-in-out;
    }
    @keyframes glow-effect {
      0%, 100% {
        filter: drop-shadow(0 0 0px rgba(255, 215, 0, 0));
        transform: scale(1);
      }
      50% {
        filter: drop-shadow(0 0 8px rgba(255, 215, 0, 1));
        transform: scale(1.1);
      }
    }
    .glow-animation .glyph-random, .glow-animation .glyph-remix, .glow-animation.palette, .glow-animation .glyph-square-gold, .glow-animation svg {
      animation: glow-effect 2s ease-in-out infinite;
    }
    .glow-animation-separator svg {
      animation: glow-effect 2s ease-in-out infinite;
    }
    #saveModal {
      transition: opacity 300ms ease-in-out, visibility 300ms ease-in-out;
      visibility: hidden;
      opacity: 0;
    }
    #saveModal.modal-visible {
      visibility: visible;
      opacity: 1;
    }

    #longPressOverlay {
      background-color: rgba(0, 0, 0, 0.95);
      opacity: 0;
      transition: opacity 200ms ease-out;
    }
    #longPressDisplay {
      opacity: 0;
      transform: scale(0.95);
      transition: opacity 200ms ease-out 50ms, transform 200ms ease-out 50ms;
    }
    #longPressOverlay.visible, #longPressDisplay.visible {
      opacity: 1;
    }
    #longPressDisplay.visible {
        transform: scale(1);
    }

    @media (max-width: 480px) {
      .ctrl { width: 44px; height: 44px; }
      #controls, .side-controls {
        grid-template-columns: 44px;
        grid-template-rows: repeat(3, 44px);
      }
       #controls {
        grid-template-columns: repeat(3, 44px);
      }
      #controlsContainer {
        justify-content: space-between;
      }
    }
    .board.no-gap-fix .tile {
      transform: scale(1.02);
    }

    /* --- FTUE STYLES --- */
    #tutorialContainer {
        position: fixed;
        inset: 0;
        z-index: 999;
        display: none; /* Initially hidden */
        transition: opacity 300ms ease-in-out;
        pointer-events: none; /* Allow clicks to pass through to active elements */
    }
    #tutorialContainer > * {
        pointer-events: auto; /* Re-enable pointer events for children */
    }
    .tutorial-active-button {
        position: relative;
        z-index: 1000;
        pointer-events: auto !important;
        opacity: 1 !important;
        cursor: pointer !important;
    }
    #skipTutorialBtn {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 1001;
        background-color: rgba(60, 60, 60, 0.8);
        color: white;
        padding: 8px 16px;
        border-radius: 20px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        cursor: pointer;
        font-size: 14px;
    }
    #finalMessageModal {
        position: absolute;
        inset: 0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1002;
        color: white;
        text-align: center;
        opacity: 0;
        pointer-events: none;
        transition: opacity 300ms ease-in-out;
    }
    #finalMessageModal.visible {
        opacity: 1;
        pointer-events: auto;
    }
    #startCreatingBtn {
        margin-top: 24px;
        background-color: #FFD700;
        color: black;
        font-weight: bold;
        padding: 12px 24px;
        border-radius: 30px;
        border: none;
        cursor: pointer;
        font-size: 18px;
    }
    #tutorialText {
        position: absolute;
        bottom: 230px;
        left: 50%;
        transform: translateX(-50%) translateY(10px);
        color: white;
        font-size: 22px;
        opacity: 0;
        transition: opacity 300ms ease-in-out, transform 300ms ease-in-out;
        pointer-events: none;
        text-align: center;
        width: 100%;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    #tutorialText.visible {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
    }

    /* --- Breathing Animation --- */
    @keyframes breathe {
      0%, 100% {
        filter: brightness(1);
      }
      50% {
        filter: brightness(0.4);
      }
    }
    .breathing-tile {
      animation: breathe 4s infinite;
    }

    /* --- Splash Screen --- */
    #splashScreen {
        font-family: 'Inter', sans-serif;
        transition: opacity 2s linear;
    }
    .splash-tutorial-focus {
        z-index: 1001; /* Bring tutorial button above splash */
        position: relative; /* Needed for z-index to work */
    }
    @keyframes fadeInText {
      0% { color: black; opacity: 0; }
      50% { color: var(--gold); opacity: 1; }
      100% { color: var(--gold); opacity: 1; }
    }
    @keyframes fadeOutText {
      from { color: var(--gold); opacity: 1; }
      to { color: black; opacity: 0; }
    }
  </style>
</head>
<body class="bg-black text-[#eaeaea] font-sans">

  <!-- Splash Screen -->
  <div id="splashScreen" class="fixed inset-0 bg-black flex items-center justify-center z-[1000]">
    <h1 id="splashText" class="text-3xl font-light" style="color: black; opacity: 0;">Follow your Intuition</h1>
  </div>

  <!-- FTUE Elements -->
  <div id="tutorialContainer">
    <button id="skipTutorialBtn">Skip</button>
  </div>

  <div id="appContainer" class="min-h-screen flex flex-col items-center justify-start p-6 pt-10 sm:pt-12">
    <div class="w-full max-w-[720px] mx-auto app-shell">
      
      <div class="relative">
        <div id="board" class="board bg-black border-black touch-none" aria-label="◊ú◊ï◊ó ◊¶◊ë◊¢◊ô◊ù" role="grid"></div>
        <div id="boardOverlay" class="absolute inset-0 bg-black opacity-0 pointer-events-none"></div>
        
        <!-- Final Message Modal is now inside the board's relative container -->
        <div id="finalMessageModal">
          <p class="text-2xl">We are tiles, tap on us too</p>
          <p class="text-lg mt-2 text-gray-400">Long-press any button for a hint</p>
          <button id="startCreatingBtn">Start Creating</button>
        </div>

        <div id="longPressOverlay" class="absolute inset-0 pointer-events-none"></div>
        <div id="longPressDisplay" class="absolute inset-0 flex flex-col items-center justify-center gap-8 sm:gap-12 pointer-events-none">
        </div>
      </div>

      <!-- Tutorial Text Container -->
      <div id="tutorialText"></div>

      <div id="controlsContainer" class="mt-11 flex justify-between items-start">
        
        <div class="side-controls">
            <button id="btnResetBoard" class="ctrl" aria-label="Reset Board" title="Reset Board">
                <span class="glyph-reset"></span>
            </button>
            <button id="btnBreathe" class="ctrl" aria-label="Breathe" title="Breathe">
                <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M12 6 C 6 10 18 14 12 18"></path>
                </svg>
            </button>
            <button id="btnGroupBreathe" class="ctrl" aria-label="Group Breathe" title="Group Breathe">
                <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M10 6 C 4 10 16 14 10 18"></path>
                    <path d="M14 6 C 8 10 20 14 14 18"></path>
                </svg>
            </button>
        </div>
        
        <div id="controls" aria-label="Control buttons">
            <button id="btnRandom" class="ctrl" aria-label="Randomize Palette" title="Shuffle">
                <span class="glyph glyph-random" aria-hidden="true"></span>
            </button>
            <button id="btnPalette" class="ctrl palette" aria-label="Switch palette" title="Switch palette"></button>
            <button id="btnRemix" class="ctrl" aria-label="Remix current Grid" title="Remix current Grid">
                <span class="glyph glyph-remix" aria-hidden="true"></span>
            </button>
            
            <button id="btnResizeUp" class="ctrl" aria-label="Increase Grid Size" title="size up">
                <span class="glyph glyph-square-gold" aria-hidden="true"></span>
            </button>
            <button id="btnGap" class="ctrl" aria-label="Grid Separator" title="Grid Separator">
                <svg viewBox="0 0 24 24" fill="none" stroke="#fff" stroke-width="2" aria-hidden="true">
                  <path d="M8 3v18M16 3v18M3 8h18M3 16h18"/>
                </svg>
            </button>
            <button id="btnResizeDown" class="ctrl" aria-label="Decrease Grid Size" title="size down">
                <span class="glyph glyph-square-white" aria-hidden="true"></span>
            </button>

            <button id="btnUndo" class="ctrl" aria-label="Undo" title="Undo">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M3 10v4c0 1.1.9 2 2 2h7"/>
                    <path d="M3 10l4-4 4 4"/>
                </svg>
            </button>
            <button id="btnBrushMode" class="ctrl" title="Mode: Drag to Copy">
                <svg viewBox="0 0 24 24" aria-hidden="true">
                    <path d="M12 2 L2 22 L22 22 Z" stroke="#fff" stroke-width="2" fill="#000" />
                </svg>
            </button>
            <button id="btnRedo" class="ctrl" aria-label="Redo" title="Redo">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                    <path d="M21 10v4c0 1.1-.9 2-2 2h-7"/>
                    <path d="M21 10l-4-4-4 4"/>
                </svg>
            </button>
        </div>

        <div class="side-controls">
            <button id="btnTutorial" class="ctrl" aria-label="Start Tutorial" title="Start Tutorial">
                <span class="glyph-tutorial"></span>
            </button>
            <button id="btnSpecialReset" class="ctrl" aria-label="Special Reset" title="Visit somewhere">
                <span class="glyph-special-reset"></span>
            </button>
            <button id="btnSave" class="ctrl" aria-label="Save" title="Save">
                <span class="glyph-save"></span>
            </button>
        </div>

      </div>

    </div>
  </div>

  <div id="saveModal" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center p-4 z-50">
    <div class="bg-[#1c1c1c] rounded-lg p-6 max-w-sm w-full text-center relative">
      <button id="btnModalClose" class="absolute top-3 right-3 text-gray-400 hover:text-white" title="Close">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
      </button>
      <img id="imagePreview" class="rounded-md mb-4 border-2 border-gray-600 max-w-full h-auto" src="" alt="Image Preview">
      <div class="mb-6 text-left" dir="ltr">
        <label for="fileNameInput" class="block text-sm font-medium text-gray-300 mb-1">feels like</label>
        <input type="text" id="fileNameInput" class="bg-gray-700 border border-gray-600 text-white text-sm rounded-lg focus:ring-blue-500 focus:border-blue-500 block w-full p-2.5" placeholder="Journey">
      </div>
      <div class="flex justify-center gap-4">
        <button id="btnModalShare" title="Share" class="bg-blue-600 hover:bg-blue-700 text-white font-bold p-3 rounded-full flex items-center justify-center">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.684 13.342C8.886 12.938 9 12.482 9 12s-.114-.938-.316-1.342m0 2.684a3 3 0 110-2.684m0 2.684l6.632 3.316m-6.632-6l6.632-3.316m0 0a3 3 0 105.367-2.684 3 3 0 00-5.367 2.684zm0 9.316a3 3 0 105.367 2.684 3 3 0 00-5.367-2.684z"></path></svg>
        </button>
        <button id="btnModalDownload" title="Download" class="bg-gray-600 hover:bg-gray-700 text-white font-bold p-3 rounded-full flex items-center justify-center">
          <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
        </button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      const PALETTES = [
        { name: 'Default', emoji: 'üåì', colors: ['#FFD700', '#424242', '#000000', '#2E7D32', '#F48FB1', '#AB47BC', '#FFFFFF', '#FFC107', '#FFEE58', '#FDD835', '#FBC02D', '#FFE082', '#FFCA28', '#FFF176', '#FF8C00', '#FF9800', '#FB8C00', '#FFA726', '#FF7043', '#FF5722', '#F4511E', '#F57C00', '#FF1744', '#F44336', '#E53935', '#D32F2F', '#C62828', '#B71C1C', '#FF5252', '#EF5350', '#E91E63', '#F06292', '#FF4081', '#AD1457', '#D81B60', '#C2185B', '#EC407A', '#9C27B0', '#7B1FA2', '#8E24AA', '#673AB7', '#5E35B1', '#3F51B5', '#3949AB', '#2196F3', '#1976D2', '#1E88E5', '#42A5F5', '#00BCD4', '#26C6DA', '#0097A7', '#80DEEA', '#4CAF50', '#43A047', '#66BB6A', '#8BC34A', '#9CCC65', '#CDDC39', '#AFB42B', '#F5F5F5', '#E0E0E0', '#BDBDBD', '#9E9E9E', '#757575'] },
        { name: 'New-York Autumn', emoji: 'üçÇ', colors: ['#8B3A3A','#A52A2A','#8B0000','#B22222','#D2691E','#FF8C00','#FF7F50','#F4A460','#CD853F','#C2A14A','#B8860B','#DAA520','#808000','#556B2F','#6B8E23','#8B4513','#5D4037','#4E342E','#3E2723','#2F4F4F','#37474F','#607D8B','#795548'] },
        { name: 'Brazilian Summer', emoji: '‚òÄÔ∏è', colors: ['#00FF7F','#1DE9B6','#00E676','#00C853','#2ECC71','#00A86B','#FFD700','#FFEB3B','#FFC107','#FDD835','#00BFFF','#1E90FF','#00B0FF','#18FFFF','#40E0D0','#FF1493','#FF69B4','#FF7F50','#FF5722','#F50057','#2962FF','#64DD17','#00C4FF'] },
        { name: 'Icelandic Winter', emoji: '‚ùÑÔ∏è', colors: ['#E6F7FF','#E1F5FE','#B3E5FC','#81D4FA','#4FC3F7','#29B6F6','#03A9F4','#90A4AE','#B0BEC5','#CFD8DC','#ECEFF1','#FFFFFF','#F5F5F5','#BDBDBD','#9E9E9E','#78909C','#546E7A','#455A64','#37474F','#263238','#A7FFEB','#80DEEA','#4DD0E1'] },
        { name: 'Japanese Spring', emoji: 'üå∏', colors: ['#FFC0CB','#FFB7C5','#FFD1DC','#F8BBD0','#F48FB1','#E6E6FA','#D1C4E9','#B39DDB','#C1E1C1','#A5D6A7','#81C784','#DCEDC8','#FFF8DC','#FFF9C4','#FFF59D','#FFECB3','#87CEFA','#90CAF9','#64B5F6','#B3E5FC','#81D4FA','#80DEEA','#A7FFEB'] },
        { name: 'Amazon Rainforest', emoji: 'üå≥', colors: ['#013220','#145A32','#1E8449','#229954','#28B463','#2ECC71','#58D68D','#82E0AA','#A9DFBF','#196F3D','#27AE60','#52BE80','#239B56','#1D8348','#117A65','#0E6655','#73C6B6','#48C9B0','#16A085','#45B39D','#138D75','#117864','#0B5345'] },
        { name: 'Desert Sunrise', emoji: 'üê™', colors: ['#FAD6A5', '#F8CBA6', '#F6BFA8', '#F3B4A9', '#F1A8AB', '#EE9CAC', '#E78B9A', '#E07A88', '#D86976', '#D15864', '#C94752', '#C23640', '#B33A3A', '#A42A34', '#95242E', '#861E28', '#781822', '#69121C', '#5A0C16', '#4B0610', '#E6E6FA', '#D8BFD8', '#DDA0DD', '#C3B1E1', '#BDB0D0'] },
        { name: 'Cherry Blossom', emoji: 'Ê°ú', iconHTML: '<span style="color: #FFB6C1;">Ê°ú</span>', colors: ['#D4A3A3', '#E1B5B5', '#EECBCB', '#F4DEDE', '#F8E9E9', '#E6DCE5', '#DCD0E2', '#C9B7D4', '#B59ECB', '#A284C2', '#8F6AAD', '#FFDDE1', '#FFC4D0', '#E0BBE4', '#FFD1DC', '#FBC4AB', '#D8BFD8', '#C3B1E1', '#BDB0D0', '#D6CADD', '#BC8F8F', '#C0A9BD', '#A389A4', '#86688B', '#69476E'] },
        { name: 'Deep Sea', emoji: 'üåä', colors: ['#000080', '#00008B', '#191970', '#0000CD', '#0000FF', '#008080', '#008B8B', '#2F4F4F', '#5F9EA0', '#66CDAA', '#000000', '#0B0C10', '#1C1C1C', '#252525', '#36454F', '#00FFFF', '#7FFFD4', '#40E0D0', '#20B2AA', '#483D8B', '#6A5ACD', '#8A2BE2', '#9370DB', '#9932CC', '#BA55D3'] },
        { name: 'Brown Noise', iconHTML: '<svg viewBox="0 0 24 24" style="width: var(--icon-size); height: var(--icon-size);"><polygon points="4,8 20,8 16,16 8,16" style="fill:#FFD700;" /></svg>', colors: ['#3E2F00', '#523F00', '#665000', '#7A6000', '#8E7000', '#A28000', '#B69000', '#CAA000', '#DEB000', '#F2C000', '#F4C306', '#F6C70C', '#F8CA12', '#FACC18', '#FCD01E', '#FED324', '#FFD52A', '#FFD730', '#FFD936', '#FFDB3C', '#FFDD42', '#FFDF48', '#FFE14E', '#FFE354', '#FFD700'] },
        { name: 'Cosmos', emoji: 'üåå', colors: ['#000000','#0B0C10','#1F2833','#263238','#37474F','#483D8B','#4B0082','#8A2BE2','#9370DB','#BA55D3','#DA70D6','#FF00FF','#FF69B4','#F8F8FF','#FFFFFF','#FFFACD','#E0FFFF','#B0E0E6','#40E0D0','#00BFFF','#1E90FF','#00008B','#191970'] },
        { name: 'healing flow', emoji: '‚ú®', colors: ['#F5FFFA', '#FAFAD2', '#FFFACD', '#E6E6FA', '#D8BFD8', '#C1E1C1', '#B0E0E6', '#AFEEEE', '#87CEFA', '#ADD8E6', '#98FB98', '#90EE90', '#66CDAA', '#20B2AA', '#3CB371', '#2E8B57', '#FFDAB9', '#FFE4C4', '#F0FFF0', '#F5F5DC', '#DCDCDC', '#C0C0C0', '#A9A9A9', '#708090', '#6A5ACD'] }
      ];

      // ---- State ----
      let activePaletteIndex = 0;
      let n = 5;
      const GOLD = '#FFD700';
      let separatorPx = 3;
      let isBrushModeOn = true; 
      let hasPerformedInitialAutofill = false; 
      let hasTriggeredFirstNudge = false;
      let hasUsedRandomize = false;
      let hasTriggeredSeparatorNudge = false;
      let isAnimating = false;
      let isBreathing = false; // State for breathing effect

      // ---- START: Refactor - Constants & helpers ----
      const SEPARATORS = [6, 5, 3, 2, 0];
      const SIZES = [50, 35, 20, 15, 10, 9, 8, 7, 6, 5, 4, 3, 2];
      const LONG_PRESS_SHOW_MS = 400;
      const LONG_PRESS_CYCLE_MS = 200;
      const AUTO_CYCLE_MS = 80;
      
      const tiles = () => Array.from(board.querySelectorAll('.tile'));
      const isGold = (el) => !!el.dataset.goldOverlay;
      const paletteLen = () => palette().length;
      const norm = (k, m = paletteLen()) => ((k % m) + m) % m;
      // ---- END: Refactor ----

      // ---- Undo/Redo State ----
      const HISTORY_LIMIT = 5;
      let history = [];
      let future = [];

      // ---- Elements ----
      const appShell = document.querySelector('.app-shell');
      const controlsContainer = document.getElementById('controlsContainer');
      const board = document.getElementById('board');
      const boardOverlay = document.getElementById('boardOverlay');
      const btnRandom = document.getElementById('btnRandom');
      const btnPalette = document.getElementById('btnPalette');
      const btnGap = document.getElementById('btnGap');
      const btnUndo = document.getElementById('btnUndo');
      const btnRedo = document.getElementById('btnRedo');
      const btnRemix = document.getElementById('btnRemix');
      const btnBrushMode = document.getElementById('btnBrushMode');
      const btnSpecialReset = document.getElementById('btnSpecialReset');
      const btnTutorial = document.getElementById('btnTutorial');
      const tutorialText = document.getElementById('tutorialText');
      const root = document.documentElement;
      const tileClasses = 'tile aspect-square w-full outline-none focus-visible:ring-inset focus-visible:ring-4 focus-visible:ring-white/90';
      // Secret Buttons
      const btnBreathe = document.getElementById('btnBreathe');
      const btnGroupBreathe = document.getElementById('btnGroupBreathe');

      // ---- Save Modal Elements ----
      const saveModal = document.getElementById('saveModal');
      const imagePreview = document.getElementById('imagePreview');
      const btnModalShare = document.getElementById('btnModalShare');
      const btnModalDownload = document.getElementById('btnModalDownload');
      const btnModalClose = document.getElementById('btnModalClose');
      const fileNameInput = document.getElementById('fileNameInput');
      let generatedImageFile = null;
      
      // ---- Visual Long Press Elements ----
      const longPressOverlay = document.getElementById('longPressOverlay');
      const longPressDisplay = document.getElementById('longPressDisplay');
      let longPressTimer = null;
      let wasLongPress = false;

      const LONG_PRESS_TEXTS = {
        btnSpecialReset: "Visit somewhere",
        btnResizeUp: "Grid Up",
        btnGap: "Toggle Gap",
        btnResizeDown: "Grid Down",
        btnRandom: "Explore this set"
      };

      // ---- FTUE Elements & State ----
      const tutorialContainer = document.getElementById('tutorialContainer');
      const finalMessageModal = document.getElementById('finalMessageModal');
      const skipTutorialBtn = document.getElementById('skipTutorialBtn');
      const startCreatingBtn = document.getElementById('startCreatingBtn');
      let currentTutorialStep = 0;
      let isTutorialActive = false;
      let tutorialInitialState = null; 

      function palette() { return PALETTES[activePaletteIndex].colors; }

      // ---- History Management ----
      function getCurrentState() {
        return { 
          n, 
          activePaletteIndex, 
          separatorPx, 
          tiles: tiles().map(el => ({ k: getIndex(el), isGold: isGold(el) })) 
        };
      }
      function areStatesEqual(stateA, stateB) {
        if (!stateA || !stateB) return false;
        if (stateA.n !== stateB.n || stateA.activePaletteIndex !== stateB.activePaletteIndex || stateA.separatorPx !== stateB.separatorPx || stateA.tiles.length !== stateB.tiles.length) return false;
        for (let i = 0; i < stateA.tiles.length; i++) {
          if (stateA.tiles[i].k !== stateB.tiles[i].k || stateA.tiles[i].isGold !== stateB.tiles[i].isGold) return false;
        }
        return true;
      }
      function applyState(state) {
        activePaletteIndex = state.activePaletteIndex;
        separatorPx = state.separatorPx;
        updatePaletteHeader();
        applySeparator();
        if (n !== state.n) {
            n = state.n;
            buildBoard(n, false);
        }
        const tileElements = tiles();
        state.tiles.forEach((tileState, i) => {
            if (tileElements[i]) {
                const el = tileElements[i];
                if (tileState.isGold) { applyGoldOverlay(el); } 
                else { delete el.dataset.goldOverlay; setIndex(el, tileState.k); }
            }
        });
      }
      function pushHistory(state) {
        if (isTutorialActive) return; 
        history.push(state);
        if (history.length > HISTORY_LIMIT) { history.shift(); }
        future = [];
        updateUndoRedoButtons();
      }
      function performAction(actionFn) {
        const beforeState = getCurrentState();
        actionFn();
        const afterState = getCurrentState();
        if (!areStatesEqual(beforeState, afterState)) {
            pushHistory({ before: beforeState, after: afterState });
            hasPerformedInitialAutofill = true;
        }
      }
      function undo() {
        if (history.length === 0) return;
        const lastAction = history.pop();
        future.push(lastAction);
        applyState(lastAction.before);
        clearAllHighlights();
        updateUndoRedoButtons();
      }
      function redo() {
        if (future.length === 0) return;
        const nextAction = future.pop();
        history.push(nextAction);
        applyState(nextAction.after);
        clearAllHighlights();
        updateUndoRedoButtons();
      }
      function updateUndoRedoButtons() {
        btnUndo.disabled = history.length === 0;
        btnRedo.disabled = future.length === 0;
      }

      // ---- Tiles & Board ----
      function getPaletteColor(k) {
        return palette()[norm(k)];
      }

      function createTile(idx = 0) {
        const d = document.createElement('div');
        d.className = tileClasses;
        d.setAttribute('role', 'gridcell');
        d.setAttribute('tabindex', '0');
        setIndex(d, idx);
        return d;
      }
      function setIndex(el, k) {
        el.dataset.k = String(k);
        if (!isGold(el)) {
          el.style.background = getPaletteColor(k);
        }
      }
      function getIndex(el) { return parseInt(el.dataset.k || '0', 10); }
      function applyGoldOverlay(el) { el.style.background = GOLD; el.dataset.goldOverlay = '1'; }
      function clearGoldOverlay(el) {
        if (isGold(el)) {
          delete el.dataset.goldOverlay;
          el.style.background = getPaletteColor(getIndex(el));
        }
      }
      function clearAllHighlights() {
        tiles().forEach(el => {
            el.classList.remove('source-highlight', 'target-highlight');
        });
      }
      function buildBoard(size, applyGold = true) {
        root.style.setProperty('--grid-size', size);
        board.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (let i = 0; i < size * size; i++) {
            const tile = createTile(0);
            if(applyGold) applyGoldOverlay(tile);
            frag.appendChild(tile);
        }
        board.appendChild(frag);
        if (applyGold) { hasPerformedInitialAutofill = false; }
      }
      function updatePaletteHeader() {
        const pal = PALETTES[activePaletteIndex];
        if (pal.iconHTML) { btnPalette.innerHTML = pal.iconHTML; } 
        else { btnPalette.innerHTML = ''; btnPalette.textContent = pal.emoji; }
        const label = `Switch palette: ${pal.name} (${activePaletteIndex + 1}/${PALETTES.length})`;
        btnPalette.title = label;
        btnPalette.setAttribute('aria-label', label);
      }
      function applySeparator() {
        root.style.setProperty('--gap-px', separatorPx + 'px');
        root.style.setProperty('--tile-radius', (separatorPx === 0 ? '0px' : '2px'));
        btnGap.title = `Grid Separator`;
        btnGap.setAttribute('aria-label', `Grid Separator`);
      }

      // ---- Board Animation ----
      async function animateBoardTransition(actionFn) {
        if (isAnimating) return;
        isAnimating = true;
        boardOverlay.style.opacity = '1';
        await new Promise(resolve => setTimeout(resolve, 350));
        actionFn();
        await new Promise(resolve => setTimeout(resolve, 50));
        boardOverlay.style.opacity = '0';
        await new Promise(resolve => setTimeout(resolve, 350));
        isAnimating = false;
      }
      
      // ---- Actions ----
      function applyInitialPattern() {
        const currentTiles = tiles();
        if (n !== 5 || currentTiles.length !== 25) return; // Only apply to 5x5 grid

        const centerIndex = 12; // Math.floor((5*5)/2)
        const blackIndex = 2; // '#000000' in default palette
        const grayIndex = 1;  // '#424242' in default palette

        currentTiles.forEach((tile, index) => {
          const row = Math.floor(index / n);
          const col = index % n;

          if (index === centerIndex) {
            applyGoldOverlay(tile);
          } else if (row === 0 || row === n - 1 || col === 0 || col === n - 1) { // Is on border
            if (row === n - 1 && (col >= 1 && col <= 3)) { // Bottom-middle 3 tiles
              setIndex(tile, grayIndex);
            } else {
              setIndex(tile, blackIndex);
            }
          } else { // Inner tiles
            setIndex(tile, grayIndex);
          }
        });
      }

      function cycleSeparator() {
          performAction(() => {
            const seq = SEPARATORS;
            let idx = seq.indexOf(separatorPx);
            if (idx === -1) { idx = seq.indexOf(seq.reduce((p, c) => (Math.abs(c - separatorPx) < Math.abs(p - separatorPx) ? c : p))); }
            separatorPx = seq[(idx + 1) % seq.length];
            applySeparator();
          });
      }
      function fillRandom() {
        tiles().forEach(el => {
          clearGoldOverlay(el);
          setIndex(el, Math.floor(Math.random() * paletteLen()));
        });
      }
      function randomizeAll() {
        performAction(fillRandom);
        hasUsedRandomize = true;
      }
      function remixGrid() {
        performAction(() => {
            let states = tiles().map(el => ({ k: getIndex(el), isGold: isGold(el) }));
            for (let i = states.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [states[i], states[j]] = [states[j], states[i]]; }
            tiles().forEach((el, i) => {
                if (states[i].isGold) { applyGoldOverlay(el); } 
                else { clearGoldOverlay(el); setIndex(el, states[i].k); }
            });
        });
      }
      
      function resetToGoldAndDefaultPalette() {
        performAction(() => {
            activePaletteIndex = 0;
            separatorPx = 3;
            n = 5;
            updatePaletteHeader();
            applySeparator();
            buildBoard(n, false); 
            applyInitialPattern();
            hasPerformedInitialAutofill = true;
        });
        setBrushMode(true);
      }

      function specialReset() {
        activePaletteIndex = Math.floor(Math.random() * PALETTES.length);
        separatorPx = SEPARATORS[Math.floor(Math.random() * SEPARATORS.length)];
        n = SIZES[Math.floor(Math.random() * SIZES.length)];
        updatePaletteHeader();
        applySeparator();
        buildBoard(n, false);
        fillRandom();
        hasPerformedInitialAutofill = true;
      }

      function switchPalette(backwards = false) {
        const shouldTriggerNudge = !hasUsedRandomize && !hasTriggeredFirstNudge;
        performAction(() => {
            const len = PALETTES.length;
            activePaletteIndex = (activePaletteIndex + (backwards ? -1 : 1) + len) % len;
            updatePaletteHeader();
            if (!hasPerformedInitialAutofill) {
                tiles().forEach(el => { clearGoldOverlay(el); setIndex(el, 0); });
            } else {
                tiles().forEach(el => {
                    if (isGold(el)) { delete el.dataset.goldOverlay; }
                    el.style.background = palette()[norm(getIndex(el))];
                });
            }
        });
        if (shouldTriggerNudge) {
            hasTriggeredFirstNudge = true;
            btnRandom.classList.add('glow-animation');
            setTimeout(() => { btnRandom.classList.remove('glow-animation'); }, 4000);
        }
      }
      
      function applyShuffledStates(states) {
          for (let i = states.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [states[i], states[j]] = [states[j], states[i]];
          }
          const newTiles = tiles();
          newTiles.forEach((el, i) => {
              if (states[i]) {
                  if (states[i].isGold) { applyGoldOverlay(el); } 
                  else { clearGoldOverlay(el); setIndex(el, states[i].k); }
              }
          });
      }

      function resizeGrid(increase = false) {
        performAction(() => {
            const oldStates = tiles().map(el => ({ k: getIndex(el), isGold: isGold(el) }));
            const oldSize = n;
            const seq = SIZES;
            let idx = seq.indexOf(n);
            if (idx === -1) { idx = seq.indexOf(seq.reduce((p, c) => (Math.abs(c - n) < Math.abs(p - n) ? c : p))); }
            idx = (idx + (increase ? -1 : 1) + seq.length) % seq.length;
            n = seq[idx];
            if (n === 50 && !hasTriggeredSeparatorNudge) {
                hasTriggeredSeparatorNudge = true; 
                btnGap.classList.add('glow-animation-separator');
                setTimeout(() => { btnGap.classList.remove('glow-animation-separator'); }, 4000); 
            }
            buildBoard(n, false); 
            
            if (n < oldSize) { 
                applyShuffledStates(oldStates);
            } else if (n > oldSize) { 
                const newRandomStates = Array.from({ length: (n*n) - (oldSize*oldSize) }, () => ({ k: Math.floor(Math.random() * paletteLen()), isGold: false }));
                const combined = [...oldStates, ...newRandomStates];
                applyShuffledStates(combined);
            }
        });
      }
      function setBrushMode(isBrushOn) {
          isBrushModeOn = isBrushOn;
          btnBrushMode.classList.toggle('brush-on', isBrushOn);
          const newTitle = isBrushModeOn ? "Brush (full)" : "Drag to COPY to 1 cell (empty)";
          btnBrushMode.title = newTitle;
          btnBrushMode.setAttribute('aria-label', newTitle);
          clearAllHighlights();
          if (pointerState.dragSource) pointerState.dragSource = null;
      }
      function toggleBrushMode() {
          setBrushMode(!isBrushModeOn);
      }
      function openModal() { saveModal.classList.add('modal-visible'); }
      function closeModal() {
        saveModal.classList.remove('modal-visible');
        if (imagePreview.src) { URL.revokeObjectURL(imagePreview.src); }
        imagePreview.src = '';
        generatedImageFile = null;
      }
      async function savePNG() {
        const btnSave = document.getElementById('btnSave');
        btnSave.disabled = true;
        clearAllHighlights();
        tiles().forEach(el => el.classList.remove('ring-inset', 'ring-4', 'ring-white', 'ring-white/90'));
        if (separatorPx === 0) { board.classList.add('no-gap-fix'); }
        try {
            const boardCanvas = await html2canvas(board, { backgroundColor: null, scale: 2 });
            const padding = 50;
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = boardCanvas.width + padding;
            finalCanvas.height = boardCanvas.height + padding;
            const ctx = finalCanvas.getContext('2d');
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
            ctx.drawImage(boardCanvas, padding / 2, padding / 2);
            finalCanvas.toBlob(async (blob) => {
                if (!blob) { console.error('Blob creation failed'); btnSave.disabled = false; return; }
                generatedImageFile = new File([blob], 'board.png', { type: 'image/png' });
                imagePreview.src = URL.createObjectURL(blob);
                fileNameInput.value = PALETTES[activePaletteIndex]?.name || 'Journey';
                const shareData = { files: [generatedImageFile] };
                btnModalShare.classList.toggle('hidden', !(navigator.share && navigator.canShare && navigator.canShare(shareData)));
                openModal();
                btnSave.disabled = false;
            }, 'image/png');
        } catch (err) {
            console.error("Failed to save PNG:", err);
            btnSave.disabled = false;
        } finally {
            if (separatorPx === 0) { board.classList.remove('no-gap-fix'); }
        }
      }
      function getSanitizedFileName() {
        let fileName = fileNameInput.value.trim() || PALETTES[activePaletteIndex]?.name || 'Journey';
        return fileName.replace(/[<>:"/\\|?*]/g, '_') + '.png';
      }

      // ---- Pointer interactions on Board ----
      const pointerState = { id: null, downEl: null, downX: 0, downY: 0, longPressTimer: null, cyclingInterval: null, suppressClick: false, isDragging: false, dragSource: null, currentTarget: null, beforeState: null };
      function onPointerDown(e) {
        if (isTutorialActive || isBreathing) return;
        const el = e.target.closest('.tile'); if (!el) return;
        e.preventDefault();
        el.setPointerCapture(e.pointerId);
        Object.assign(pointerState, { id: e.pointerId, downEl: el, suppressClick: false, isDragging: false, dragSource: null, currentTarget: null, cyclingInterval: null, beforeState: getCurrentState() });
        pointerState.longPressTimer = setTimeout(() => {
            if (pointerState.isDragging) return;
            pointerState.cyclingInterval = setInterval(() => { clearGoldOverlay(el); setIndex(el, getIndex(el) + 1); hasPerformedInitialAutofill = true; }, AUTO_CYCLE_MS);
        }, LONG_PRESS_CYCLE_MS);
        if (isBrushModeOn) { pointerState.downX = e.clientX; pointerState.downY = e.clientY; } 
        else { clearAllHighlights(); el.classList.add('source-highlight'); pointerState.dragSource = el; }
      }
      function onPointerMove(e) {
        if (pointerState.id !== e.pointerId) return;
        const dist = Math.hypot(e.clientX - pointerState.downX, e.clientY - pointerState.downY);
        if (!pointerState.isDragging && dist >= 8) {
            clearTimeout(pointerState.longPressTimer); clearInterval(pointerState.cyclingInterval);
            pointerState.longPressTimer = null; pointerState.cyclingInterval = null;
            pointerState.isDragging = true; pointerState.suppressClick = true;
            if (isBrushModeOn) { pointerState.dragSource = pointerState.downEl; clearGoldOverlay(pointerState.dragSource); }
        }
        if (pointerState.isDragging) {
            const targetEl = document.elementFromPoint(e.clientX, e.clientY)?.closest('.tile');
            if (targetEl && pointerState.currentTarget !== targetEl) {
                if (isBrushModeOn) {
                    pointerState.currentTarget?.classList.remove('ring-4', 'ring-white');
                    pointerState.currentTarget = targetEl;
                    clearGoldOverlay(targetEl); setIndex(targetEl, getIndex(pointerState.dragSource));
                    targetEl.classList.add('ring-4', 'ring-white');
                } else {
                    pointerState.currentTarget?.classList.remove('target-highlight');
                    if (targetEl !== pointerState.dragSource) {
                        targetEl.classList.add('target-highlight');
                        pointerState.currentTarget = targetEl;
                    } else { pointerState.currentTarget = null; }
                }
            }
        }
      }
      function onPointerUp(e) {
        if (isTutorialActive || isBreathing) return;
        clearTimeout(pointerState.longPressTimer);
        if (pointerState.cyclingInterval) { clearInterval(pointerState.cyclingInterval); pointerState.suppressClick = true; }
        const beforeState = pointerState.beforeState;
        if (pointerState.isDragging) {
            if (!isBrushModeOn && pointerState.currentTarget) {
                const sourceEl = pointerState.dragSource; const targetEl = pointerState.currentTarget;
                if (isGold(sourceEl)) { applyGoldOverlay(targetEl); } 
                else { clearGoldOverlay(targetEl); setIndex(targetEl, getIndex(sourceEl)); }
            }
        } else if (!pointerState.suppressClick && e.target.closest('.tile')) {
            const tile = e.target.closest('.tile');
            clearGoldOverlay(tile); setIndex(tile, getIndex(tile) + 1);
        }
        const afterState = getCurrentState();
        if (beforeState && !areStatesEqual(beforeState, afterState)) {
             pushHistory({ before: beforeState, after: afterState }); hasPerformedInitialAutofill = true;
        }
        clearAllHighlights();
        pointerState.currentTarget?.classList.remove('ring-4', 'ring-white', 'target-highlight');
        Object.assign(pointerState, { id: null, downEl: null, isDragging: false, dragSource: null, currentTarget: null, beforeState: null });
      }
      function updateLayout() {
        if (window.innerWidth < 768) { appShell.style.width = ''; return; }
        const controlsHeight = controlsContainer.offsetHeight;
        const viewportHeight = window.innerHeight;
        const topMargin = parseInt(window.getComputedStyle(appShell.parentElement).paddingTop, 10);
        const availableHeight = viewportHeight - controlsHeight - (topMargin * 2);
        const newWidth = Math.min(720, window.innerWidth * 0.85, availableHeight);
        appShell.style.width = `${newWidth}px`;
      }
      board.addEventListener('pointerdown', onPointerDown);
      board.addEventListener('pointermove', onPointerMove);
      board.addEventListener('pointerup', onPointerUp);
      board.addEventListener('pointercancel', onPointerUp);

      // ---- Breathing Effect ----
      function setAllControlsDisabled(disabled) {
        document.querySelectorAll('.ctrl').forEach(btn => {
            btn.disabled = disabled;
        });
      }

      // --- UPDATED: Breathing effect with explicit transition property setting ---
      async function startBreathingEffect(isGrouped = false) {
          if (isBreathing || isTutorialActive) return;
          isBreathing = true;
          setAllControlsDisabled(true);

          // Step 1: Fade out controls over 2 seconds
          controlsContainer.style.transition = 'opacity 2s linear';
          controlsContainer.classList.add('controls-hidden');
          await new Promise(resolve => setTimeout(resolve, 2000));

          // Step 2: Start breathing animation on tiles
          const allTiles = tiles();
          if (isGrouped) {
              const colorDelayMap = new Map();
              const uniqueColors = [...new Set(allTiles.map(tile => {
                  return isGold(tile) ? GOLD : tile.style.backgroundColor;
              }))];
              
              uniqueColors.forEach(color => {
                  colorDelayMap.set(color, Math.random() * 3);
              });

              allTiles.forEach(tile => {
                  const colorKey = isGold(tile) ? GOLD : tile.style.backgroundColor;
                  const delay = colorDelayMap.get(colorKey);
                  tile.style.animationDelay = `${delay}s`;
                  tile.classList.add('breathing-tile');
              });
          } else {
              allTiles.forEach(tile => {
                  tile.style.animationDelay = `${Math.random() * 3}s`;
                  tile.classList.add('breathing-tile');
              });
          }

          // Wait for the 10-second breathing animation to complete
          await new Promise(resolve => setTimeout(resolve, 10000));

          // Clean up tile animations
          allTiles.forEach(tile => {
              tile.classList.remove('breathing-tile');
              tile.style.animationDelay = '';
          });

          // Step 3: Fade in controls over 1.2 seconds
          controlsContainer.style.transition = 'opacity 1.2s linear';
          controlsContainer.classList.remove('controls-hidden');
          await new Promise(resolve => setTimeout(resolve, 1200));

          // Re-enable controls and reset state
          setAllControlsDisabled(false);
          updateUndoRedoButtons();
          isBreathing = false;
          // Reset transition to null so it doesn't interfere with other potential style changes
          controlsContainer.style.transition = '';
      }


      // ---- Button Clicks ----
      function handleCtrlClick(e, actionFn) {
        if (isTutorialActive || isBreathing) return;
        if (wasLongPress) {
          wasLongPress = false;
          return;
        }
        actionFn();
      }
      document.getElementById('btnRandom').addEventListener('click', (e) => handleCtrlClick(e, randomizeAll));
      btnRemix.addEventListener('click', (e) => handleCtrlClick(e, remixGrid));
      btnPalette.addEventListener('click', (e) => handleCtrlClick(e, () => switchPalette()));
      document.getElementById('btnResetBoard').addEventListener('click', (e) => handleCtrlClick(e, () => animateBoardTransition(resetToGoldAndDefaultPalette)));
      btnSpecialReset.addEventListener('click', (e) => handleCtrlClick(e, () => animateBoardTransition(() => performAction(specialReset))));
      document.getElementById('btnResizeUp').addEventListener('click', (e) => handleCtrlClick(e, () => animateBoardTransition(() => resizeGrid(true))));
      document.getElementById('btnResizeDown').addEventListener('click', (e) => handleCtrlClick(e, () => animateBoardTransition(() => resizeGrid(false))));
      document.getElementById('btnSave').addEventListener('click', (e) => handleCtrlClick(e, savePNG));
      btnGap.addEventListener('click', (e) => handleCtrlClick(e, cycleSeparator));
      btnBrushMode.addEventListener('click', (e) => handleCtrlClick(e, toggleBrushMode));
      btnUndo.addEventListener('click', (e) => handleCtrlClick(e, undo));
      btnRedo.addEventListener('click', (e) => handleCtrlClick(e, redo));
      // Breathing effect listeners
      btnBreathe.addEventListener('click', () => startBreathingEffect(false));
      btnGroupBreathe.addEventListener('click', () => startBreathingEffect(true));


      // ---- Modal Listeners ----
      btnModalShare.addEventListener('click', async () => {
          if (!generatedImageFile) return;
          const fileToShare = new File([generatedImageFile], getSanitizedFileName(), { type: generatedImageFile.type });
          try { await navigator.share({ files: [fileToShare], title: 'My Color Grid' }); } 
          catch (err) { if (err.name !== 'AbortError') { console.error('Share API error:', err); } }
      });
      btnModalDownload.addEventListener('click', () => {
          if (!generatedImageFile) return;
          const link = document.createElement('a');
          link.href = URL.createObjectURL(generatedImageFile);
          link.download = getSanitizedFileName();
          link.click();
          URL.revokeObjectURL(link.href);
          closeModal();
      });
      btnModalClose.addEventListener('click', closeModal);

      // ---- Visual Long Press Logic ----
      function hideLongPressDisplay() {
          clearTimeout(longPressTimer);
          longPressOverlay.classList.remove('visible');
          longPressDisplay.classList.remove('visible');
          setTimeout(() => { longPressDisplay.innerHTML = ''; }, 250);
      }
      function handlePointerDownCtrl(e) {
          if (isTutorialActive || isBreathing) return;
          const btn = e.currentTarget;
          // Don't show long press for secret buttons
          if (btn.id === 'btnBreathe' || btn.id === 'btnGroupBreathe') return;

          longPressTimer = setTimeout(() => {
              wasLongPress = true;
              
              if (btn.id === 'btnBrushMode') {
                  const customHTML = `
                      <div class="flex flex-col items-center justify-center gap-4 text-lg text-gray-300">
                          <div class="flex items-center gap-4">
                              <svg viewBox="0 0 24 24" style="width: var(--icon-size); height: var(--icon-size);">
                                  <path d="M12 2 L2 22 L22 22 Z" stroke="#fff" stroke-width="2" fill="#fff" />
                              </svg>
                              <span>Brush</span>
                          </div>
                          <div class="flex items-center gap-4">
                              <svg viewBox="0 0 24 24" style="width: var(--icon-size); height: var(--icon-size);">
                                  <path d="M12 2 L2 22 L22 22 Z" stroke="#fff" stroke-width="2" fill="#000" />
                              </svg>
                              <span>Drag and Copy</span>
                          </div>
                      </div>
                  `;
                  longPressDisplay.innerHTML = customHTML;
              } else {
                  let iconElement;
                  if (btn.classList.contains('palette')) {
                      iconElement = btn.cloneNode(true);
                      iconElement.style.background = 'transparent';
                      iconElement.style.border = 'none';
                  } else {
                      iconElement = btn.querySelector('.glyph, svg, .glyph-save, .glyph-reset, .glyph-special-reset, .glyph-tutorial');
                  }

                  if (!iconElement) return;

                  const clonedIcon = iconElement.cloneNode(true);
                  
                  const baseIconSize = parseInt(getComputedStyle(root).getPropertyValue('--icon-size'));
                  const targetIconSize = baseIconSize * 2;

                  if (btn.classList.contains('palette')) {
                    clonedIcon.style.fontSize = `${targetIconSize}px`;
                  } else {
                    clonedIcon.style.width = `${targetIconSize}px`;
                    clonedIcon.style.height = `${targetIconSize}px`;
                  }

                  const textElement = document.createElement('p');
                  
                  if (btn.id === 'btnPalette') {
                    textElement.textContent = activePaletteIndex === 0 ? "The Journey" : PALETTES[activePaletteIndex].name;
                  } else {
                    textElement.textContent = LONG_PRESS_TEXTS[btn.id] || btn.title;
                  }

                  textElement.className = 'text-lg text-gray-300 text-center px-4';
                  
                  longPressDisplay.innerHTML = '';
                  longPressDisplay.appendChild(clonedIcon);
                  longPressDisplay.appendChild(textElement);
              }
              
              longPressOverlay.classList.add('visible');
              longPressDisplay.classList.add('visible');
          }, LONG_PRESS_SHOW_MS);
      }
      document.querySelectorAll('.ctrl').forEach(btn => {
          btn.addEventListener('pointerdown', handlePointerDownCtrl);
          btn.addEventListener('pointerup', hideLongPressDisplay);
          btn.addEventListener('pointerleave', hideLongPressDisplay);
      });

      // ---- FTUE LOGIC ----
      
      function switchToAutumnPalette() {
        const autumnPaletteIndex = PALETTES.findIndex(p => p.name === 'New-York Autumn');
        if (autumnPaletteIndex !== -1) {
            activePaletteIndex = autumnPaletteIndex;
            updatePaletteHeader();
            tiles().forEach(el => {
                if (isGold(el)) { delete el.dataset.goldOverlay; }
                el.style.background = palette()[norm(getIndex(el))];
            });
        } else {
            switchPalette(); // Fallback
        }
      }

      function handleTutorialResizeStep() {
        // Hide the text immediately on click
        tutorialText.classList.remove('visible');

        n = 35;
        separatorPx = 2;
        buildBoard(n, false);
        applySeparator();
        fillRandom();

        // Shorten delay to 0.7 seconds
        setTimeout(() => {
            boardOverlay.style.opacity = '0.7';
            setTimeout(advanceTutorial, 350); 
        }, 700); 
      }

      const tutorialSteps = [
        { btnId: 'btnRemix', text: 'I am Shuffle', animationClass: 'glow-animation', action: remixGrid },
        { btnId: 'btnUndo', text: 'I am Undo', animationClass: 'glow-animation', action: () => { /* Action is now handled by startTutorial */ } },
        { btnId: 'btnRandom', text: 'I explore the mood', animationClass: 'glow-animation', action: randomizeAll },
        { btnId: 'btnPalette', text: 'I change the mood', animationClass: 'glow-animation', action: switchToAutumnPalette },
        { btnId: 'btnGap', text: 'I set the boundaries', animationClass: 'glow-animation-separator', action: () => { separatorPx = 0; applySeparator(); } },
        { btnId: 'btnResizeUp', text: 'I will scale', animationClass: 'glow-animation', action: handleTutorialResizeStep, advancesManually: true },
        { isFinalScreen: true }
      ];

      function setAllTutorialControlsEnabled(enabled) {
          document.querySelectorAll('.ctrl').forEach(btn => {
              btn.disabled = !enabled;
              if (enabled) {
                  btn.classList.remove('tutorial-active-button', 'glow-animation', 'glow-animation-separator');
              }
          });
      }

      function advanceTutorial() {
          tutorialText.classList.remove('visible');
          currentTutorialStep++;
          const step = tutorialSteps[currentTutorialStep];
          if (step.isFinalScreen) {
              finalMessageModal.classList.add('visible');
          } else {
              setupTutorialStep();
          }
      }

      function setupTutorialStep() {
          const resizeStepIndex = tutorialSteps.findIndex(step => step.btnId === 'btnResizeUp');
          if (currentTutorialStep >= resizeStepIndex) {
              skipTutorialBtn.style.display = 'none';
          } else {
              skipTutorialBtn.style.display = 'block';
          }

          setAllTutorialControlsEnabled(false);
          const step = tutorialSteps[currentTutorialStep];
          const activeBtn = document.getElementById(step.btnId);
          
          if (activeBtn) {
              setTimeout(() => {
                  tutorialText.textContent = step.text;
                  tutorialText.classList.add('visible');
              }, 300);

              activeBtn.disabled = false;
              activeBtn.classList.add('tutorial-active-button', step.animationClass);

              const handleStepClick = () => {
                  activeBtn.classList.remove('tutorial-active-button', step.animationClass);
                  step.action();
                  activeBtn.removeEventListener('click', handleStepClick);
                  if (!step.advancesManually) {
                    setTimeout(advanceTutorial, 300); 
                  }
              };
              activeBtn.addEventListener('click', handleStepClick);
          }
      }
      
      function skipTutorial() {
          isTutorialActive = false;
          tutorialContainer.style.opacity = '0';
          setTimeout(() => { 
            tutorialContainer.style.display = 'none'; 
            tutorialText.classList.remove('visible');
          }, 300);
          
          const controlsOverlay = document.getElementById('tutorialControlsOverlay');
          if (controlsOverlay) {
              controlsOverlay.remove();
          }

          boardOverlay.style.opacity = '0';
          finalMessageModal.classList.remove('visible');
          
          setAllTutorialControlsEnabled(true);
          
          // ** NEW: Restore state on skip **
          if (tutorialInitialState) {
              applyState(tutorialInitialState);
              history = [];
              future = [];
              updateUndoRedoButtons();
          } else {
              resetToGoldAndDefaultPalette();
          }
          
          try {
              localStorage.setItem('hasCompletedTutorial', 'true');
          } catch (e) {
              console.warn('Could not save tutorial completion status to localStorage.');
          }
      }
      
      async function endTutorialWithAnimation() {
          startCreatingBtn.disabled = true;

          boardOverlay.style.transition = 'opacity 200ms ease-in-out';
          boardOverlay.style.opacity = '1';
          await new Promise(resolve => setTimeout(resolve, 200));

          // ** NEW: Restore state on end **
          if (tutorialInitialState) {
              applyState(tutorialInitialState);
          } else {
              resetToGoldAndDefaultPalette();
          }

          isTutorialActive = false;
          tutorialContainer.style.opacity = '0';
          finalMessageModal.classList.remove('visible');
          const controlsOverlay = document.getElementById('tutorialControlsOverlay');
          if (controlsOverlay) {
              controlsOverlay.remove();
          }
          setTimeout(() => { 
            tutorialContainer.style.display = 'none'; 
            tutorialText.classList.remove('visible');
          }, 300);
          
          setAllTutorialControlsEnabled(true);
          history = []; // Reset history as requested
          future = [];
          updateUndoRedoButtons();
          try {
              localStorage.setItem('hasCompletedTutorial', 'true');
          } catch (e) {
              console.warn('Could not save tutorial completion status to localStorage.');
          }

          boardOverlay.style.opacity = '0';
          await new Promise(resolve => setTimeout(resolve, 200));

          boardOverlay.style.transition = 'opacity 350ms ease-in-out';
          startCreatingBtn.disabled = false;
      }

      function startTutorial() {
          isTutorialActive = true;
          currentTutorialStep = 0;
          
          // ** NEW: Save user's state BEFORE resetting for the tutorial **
          tutorialInitialState = getCurrentState(); 
          
          resetToGoldAndDefaultPalette(); 
          history = []; 
          future = [];
          updateUndoRedoButtons();
          
          // The Undo step in the tutorial needs a state to revert to.
          // We'll give it the clean initial pattern state.
          const tutorialUndoState = getCurrentState();
          tutorialSteps.find(step => step.btnId === 'btnUndo').action = () => applyState(tutorialUndoState);


          const controlsOverlay = document.createElement('div');
          controlsOverlay.id = 'tutorialControlsOverlay';
          controlsOverlay.style.position = 'absolute';
          controlsOverlay.style.inset = '0';
          controlsOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.55)';
          controlsOverlay.style.borderRadius = '8px';
          controlsOverlay.style.zIndex = '990'; 
          controlsContainer.appendChild(controlsOverlay);

          tutorialContainer.style.display = 'block';
          setTimeout(() => { tutorialContainer.style.opacity = '1'; }, 10); 
          
          setupTutorialStep();
      }

      skipTutorialBtn.addEventListener('click', skipTutorial);
      startCreatingBtn.addEventListener('click', endTutorialWithAnimation);
      btnTutorial.addEventListener('click', startTutorial);

      // ---- Init ----
      async function initializeApp() {
        // Get elements
        const splashScreen = document.getElementById('splashScreen');
        const splashText = document.getElementById('splashText');
        const appContainer = document.getElementById('appContainer');
        const tutorialButton = document.getElementById('btnTutorial');
        
        // --- Run original Init Logic FIRST to build the app invisibly ---
        buildBoard(n, false); 
        applyInitialPattern();
        hasPerformedInitialAutofill = true;
        updatePaletteHeader();
        applySeparator();
        updateUndoRedoButtons();
        setBrushMode(true);
        updateLayout();
        window.addEventListener('resize', updateLayout);
        window.addEventListener('contextmenu', e => e.preventDefault());
        
        // --- Splash Animation Sequence ---

        // 1. Fade in text (2.5s) and hold (2.5s)
        splashText.style.animation = 'fadeInText 2.5s linear forwards';
        await new Promise(r => setTimeout(r, 5000));

        // 2. Fade out text
        splashText.style.animation = 'fadeOutText 1.5s linear forwards';
        await new Promise(r => setTimeout(r, 1500));

        // 3. Bring tutorial button above the splash screen
        tutorialButton.classList.add('splash-tutorial-focus');
        
        // Hide the text element
        splashText.style.display = 'none';

        // Hold the dot for 1.5s
        await new Promise(r => setTimeout(r, 1500)); 

        // 4. Fade out the splash screen itself, revealing the app underneath
        splashScreen.style.opacity = '0';
        
        await new Promise(r => setTimeout(r, 2000));

        // 5. Clean up
        splashScreen.remove();
        tutorialButton.classList.remove('splash-tutorial-focus');
      }

      initializeApp();

    })();
  </script>
</body>
</html>
