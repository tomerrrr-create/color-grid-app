<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Color Grid App</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

  <!-- Chosen Palette: Minimalist Dark Theme -->
  <!-- Application Structure Plan: The application uses a simple, focused structure: a central, interactive color grid (the "board") serves as the main canvas. Below it, a two-row control panel provides access to all global actions. This structure was chosen for its clarity and directness, keeping the user's attention on their creation while ensuring tools for manipulation (palettes, randomization), and utilities (resize, save) are immediately accessible. The user flow is intuitive: direct manipulation on the canvas for fine-tuning, and global controls for broad changes. -->
  <!-- Visualization & Content Choices: The core of the app is the color grid, presented as an interactive HTML grid (divs styled with CSS). Goal: Creative exploration and visual composition. Interaction: Pointer events (click, long-press, drag-and-drop) are used for direct, tactile manipulation of tile colors. Global controls are represented by icon-only buttons to maintain a clean, language-agnostic interface, with tooltips providing clarity. Goal: Provide powerful tools without cluttering the UI. Justification: This approach creates a game-like, engaging experience. The gradient function was removed to simplify the feature set. The implementation is pure Vanilla JS and DOM manipulation, confirming NO SVG/Mermaid is used. -->
  <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

  <style>
    /* Custom properties for dynamic styling controlled by JS */
    :root {
      --grid-size: 8;
      --gap-px: 3px;
      --tile-radius: 2px;
      --separator-icon-thickness: 3px;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(var(--grid-size), 1fr);
      gap: var(--gap-px);
      border-width: var(--gap-px);
      border-radius: 6px;
    }
    .tile {
      border-radius: var(--tile-radius);
    }
    /* Full definition for the separator icon */
    .icon-sep::before,
    .icon-sep::after {
      content: '';
      position: absolute;
      left: 10%;
      right: 10%;
      background-color: #eaeaea;
      border-radius: 2px;
      height: var(--separator-icon-thickness);
    }
    .icon-sep::before { top: 30%; }
    .icon-sep::after { bottom: 30%; }
  </style>
</head>
<body class="bg-[#111] text-[#eaeaea] font-sans">

  <div class="min-h-screen grid place-items-center p-6">
    <div class="w-full max-w-[720px] mx-auto" style="width: min(92vmin, 720px);">
      
      <!-- Color Grid Board -->
      <div id="board" class="board bg-black border-black" aria-label="◊ú◊ï◊ó ◊¶◊ë◊¢◊ô◊ù" role="grid"></div>

      <!-- Controls Panel -->
      <div class="mt-11 flex flex-col items-center gap-3.5" aria-label="◊ë◊ß◊®◊ï◊™">
        <!-- Top Row -->
        <div class="flex justify-center flex-wrap gap-4">
          <button id="btnRandom" class="btn" aria-label="◊®◊†◊ì◊ï◊û◊ú◊ô◊ï◊™" title="Randomize (active palette)">
            <span class="glyph w-[26px] h-[26px] rounded-full bg-gradient-to-r from-black from-50% to-white to-50% border-2 border-[#222]" aria-hidden="true"></span>
          </button>
          <button id="btnPalette" class="btn" aria-label="◊î◊ó◊ú◊§◊™ ◊§◊ú◊ò◊î" title="Palette">
            <span id="paletteEmoji" class="text-[26px] leading-none" aria-hidden="true">üåì</span>
            <span class="sr-only" id="paletteName">Default</span>
          </button>
        </div>
        <!-- Bottom Row -->
        <div class="flex justify-center flex-wrap gap-4">
          <button id="btnReset" class="btn" aria-label="◊ê◊ô◊§◊ï◊° ◊ú◊ñ◊î◊ë + ◊§◊ú◊ò◊™ ◊ì◊ô◊§◊ï◊ú◊ò" title="Reset to Gold + Default Palette">
            <span class="glyph w-[26px] h-[26px] bg-black border-[3px] border-[#FFD700] rounded-[3px]" aria-hidden="true"></span>
          </button>
          <button id="btnResize" class="btn" aria-label="◊©◊ô◊†◊ï◊ô ◊í◊ï◊ì◊ú" title="Resize (#)">
            <span class="glyph text-[26px] text-[#eaeaea] font-bold leading-none">#</span>
          </button>
          <button id="btnSeparator" class="btn" aria-label="◊û◊§◊®◊ô◊ì: ◊¢◊ï◊ë◊ô ◊î◊û◊§◊®◊ô◊ì ◊ë◊ô◊ü ◊ê◊®◊ô◊ó◊ô◊ù" title="◊û◊§◊®◊ô◊ì: 3px">
            <span class="glyph icon-sep relative w-[26px] h-[26px] block"></span>
            <span class="sr-only" id="sepValue">3px</span>
          </button>
          <button id="btnSave" class="btn" aria-label="◊©◊û◊ï◊® PNG" title="Save PNG">
            <span class="glyph w-[26px] h-[26px] relative">
                <span class="absolute w-[12px] h-[12px] rounded-full bg-white top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2"></span>
            </span>
          </button>
        </div>
      </div>

    </div>
  </div>

  <script>
    // Tailwind CSS Custom JIT Classes (for dynamic classes)
    tailwind.config = {
      theme: {
        extend: {
          // No extensions needed for this app
        }
      }
    }

    // Base classes used by JS
    const btnClasses = 'btn w-[50px] h-[50px] rounded-[14px] bg-[#1f1f1f] border border-[#2a2a2a] grid place-items-center cursor-pointer transition-transform duration-75 ease-in-out hover:bg-[#232323] active:translate-y-px active:scale-[0.98] focus-visible:ring-2 focus-visible:ring-white/20 outline-none';
    const tileClasses = 'tile aspect-square w-full outline-none focus-visible:ring-inset focus-visible:ring-4 focus-visible:ring-white/90';
    const srOnlyClasses = 'sr-only absolute w-px h-px p-0 -m-px overflow-hidden whitespace-nowrap border-0';
    
    // Apply base classes
    document.querySelectorAll('.btn').forEach(el => el.className = btnClasses);
    document.querySelectorAll('.sr-only').forEach(el => el.className = srOnlyClasses);

    (function() {
      const PALETTES = [
        { name: 'Default', emoji: 'üåì', colors: ['#FFD700','#FFC107','#FFEE58','#FDD835','#FBC02D','#FFE082','#FFCA28','#FFF176','#FF8C00','#FF9800','#FB8C00','#FFA726','#FF7043','#FF5722','#F4511E','#F57C00','#FF1744','#F44336','#E53935','#D32F2F','#C62828','#B71C1C','#FF5252','#EF5350','#E91E63','#F06292','#FF4081','#AD1457','#D81B60','#C2185B','#EC407A','#F48FB1','#9C27B0','#7B1FA2','#8E24AA','#AB47BC','#673AB7','#5E35B1','#3F51B5','#3949AB','#2196F3','#1976D2','#1E88E5','#42A5F5','#00BCD4','#26C6DA','#0097A7','#80DEEA','#4CAF50','#43A047','#2E7D32','#66BB6A','#8BC34A','#9CCC65','#CDDC39','#AFB42B','#FFFFFF','#F5F5F5','#E0E0E0','#BDBDBD','#9E9E9E','#757575','#424242','#000000'] },
        { name: 'New-York Autumn', emoji: 'üçÇ', colors: ['#8B3A3A','#A52A2A','#8B0000','#B22222','#D2691E','#FF8C00','#FF7F50','#F4A460','#CD853F','#C2A14A','#B8860B','#DAA520','#808000','#556B2F','#6B8E23','#8B4513','#5D4037','#4E342E','#3E2723','#2F4F4F','#37474F','#607D8B','#795548'] },
        { name: 'Brazilian Summer', emoji: '‚òÄÔ∏è', colors: ['#00FF7F','#1DE9B6','#00E676','#00C853','#2ECC71','#00A86B','#FFD700','#FFEB3B','#FFC107','#FDD835','#00BFFF','#1E90FF','#00B0FF','#18FFFF','#40E0D0','#FF1493','#FF69B4','#FF7F50','#FF5722','#F50057','#2962FF','#64DD17','#00C4FF'] },
        { name: 'Icelandic Winter', emoji: '‚ùÑÔ∏è', colors: ['#E6F7FF','#E1F5FE','#B3E5FC','#81D4FA','#4FC3F7','#29B6F6','#03A9F4','#90A4AE','#B0BEC5','#CFD8DC','#ECEFF1','#FFFFFF','#F5F5F5','#BDBDBD','#9E9E9E','#78909C','#546E7A','#455A64','#37474F','#263238','#A7FFEB','#80DEEA','#4DD0E1'] },
        { name: 'Japanese Spring', emoji: 'üå∏', colors: ['#FFC0CB','#FFB7C5','#FFD1DC','#F8BBD0','#F48FB1','#E6E6FA','#D1C4E9','#B39DDB','#C1E1C1','#A5D6A7','#81C784','#DCEDC8','#FFF8DC','#FFF9C4','#FFF59D','#FFECB3','#87CEFA','#90CAF9','#64B5F6','#B3E5FC','#81D4FA','#80DEEA','#A7FFEB'] },
        { name: 'Amazon Rainforest', emoji: 'üå≥', colors: ['#013220','#145A32','#1E8449','#229954','#28B463','#2ECC71','#58D68D','#82E0AA','#A9DFBF','#196F3D','#27AE60','#52BE80','#239B56','#1D8348','#117A65','#0E6655','#73C6B6','#48C9B0','#16A085','#45B39D','#138D75','#117864','#0B5345'] },
        { name: 'Sahara Desert', emoji: 'üê™', colors: ['#F4E1A1','#E2C275','#CDA434','#B68900','#E59866','#CA6F1E','#F5CBA7','#EDBB99','#E67E22','#D35400','#BA4A00','#A04000','#873600','#784212','#6E2C00','#935116','#B9770E','#9C640C','#7E5109','#5D6D7E','#34495E','#2C3E50','#212F3C'] },
        { name: 'Cosmos', emoji: 'üåå', colors: ['#000000','#0B0C10','#1F2833','#263238','#37474F','#483D8B','#4B0082','#8A2BE2','#9370DB','#BA55D3','#DA70D6','#FF00FF','#FF69B4','#F8F8FF','#FFFFFF','#FFFACD','#E0FFFF','#B0E0E6','#40E0D0','#00BFFF','#1E90FF','#00008B','#191970'] },
        { name: "Dreamer's Soul", emoji: 'ü¶Ñ', colors: ['#F5F3FF','#EDE9FE','#DDD6FE','#C4B5FD','#A78BFA','#8B5CF6','#9D7FEA','#8B6FCB','#7A5BA6','#FDF6E3','#FCE7B2','#FDE68A','#FACC15','#EAB308','#FDF4FF','#D6BCFA','#B794F4','#E2E8F0','#CBD5E1','#94A3B8','#64748B','#A1A1AA','#D1D5DB'] }
      ];

      // ---- State ----
      let activePaletteIndex = 0;
      let n = 8;
      const GOLD = '#FFD700';
      let separatorPx = 3;

      // ---- Elements ----
      const board = document.getElementById('board');
      const paletteEmojiEl = document.getElementById('paletteEmoji');
      const paletteNameEl = document.getElementById('paletteName');
      const btnSeparator = document.getElementById('btnSeparator');
      const sepValueEl = document.getElementById('sepValue');
      const root = document.documentElement;

      function palette() { return PALETTES[activePaletteIndex].colors; }

      // ---- Tiles ----
      let initialBuildGoldOverlay = true;
      function createTile(idx = 0) {
        const d = document.createElement('div');
        d.className = tileClasses;
        d.setAttribute('role', 'gridcell');
        d.setAttribute('tabindex', '0');
        setIndex(d, idx);
        if (initialBuildGoldOverlay) applyGoldOverlay(d);
        return d;
      }
      function setIndex(el, k) {
        el.dataset.k = String(k);
        if (!el.dataset.goldOverlay) {
          const m = palette().length;
          el.style.background = palette()[((k % m) + m) % m];
        }
      }
      function getIndex(el) { return parseInt(el.dataset.k || '0', 10); }
      function applyGoldOverlay(el) { el.style.background = GOLD; el.dataset.goldOverlay = '1'; }
      function clearGoldOverlay(el) {
        if (el.dataset.goldOverlay) {
          delete el.dataset.goldOverlay;
          const k = getIndex(el), m = palette().length;
          el.style.background = palette()[k % m];
        }
      }

      function buildBoard(size) {
        root.style.setProperty('--grid-size', size);
        board.innerHTML = '';
        const frag = document.createDocumentFragment();
        for (let i = 0; i < size * size; i++) frag.appendChild(createTile(0));
        board.appendChild(frag);
        const first = board.querySelector('.tile'); if (first) first.focus();
      }
      
      function updatePaletteHeader() {
        const pal = PALETTES[activePaletteIndex];
        paletteEmojiEl.textContent = pal.emoji;
        paletteNameEl.textContent = pal.name + ` (${activePaletteIndex + 1}/${PALETTES.length})`;
      }

      function applySeparator() {
        root.style.setProperty('--gap-px', separatorPx + 'px');
        const iconPx = Math.max(1, separatorPx / 1.5);
        root.style.setProperty('--separator-icon-thickness', iconPx + 'px');
        btnSeparator.title = '◊û◊§◊®◊ô◊ì: ' + separatorPx + 'px';
        btnSeparator.setAttribute('aria-label', '◊û◊§◊®◊ô◊ì: ◊¢◊ï◊ë◊ô ◊î◊û◊§◊®◊ô◊ì ◊ë◊ô◊ü ◊ê◊®◊ô◊ó◊ô◊ù ' + separatorPx + ' ◊§◊ô◊ß◊°◊ú◊ô◊ù');
        sepValueEl.textContent = separatorPx + 'px';
      }
      function cycleSeparator(forward = true) {
        separatorPx = (separatorPx + (forward ? 1 : -1) + 9) % 9;
        applySeparator();
      }

      // ---- Actions ----
      function cycleTile(el, step = 1) { clearGoldOverlay(el); setIndex(el, getIndex(el) + step); }
      function randomizeAll() {
        const m = palette().length;
        board.querySelectorAll('.tile').forEach(el => {
          clearGoldOverlay(el);
          setIndex(el, Math.floor(Math.random() * m));
        });
      }
      function resetToGoldAndDefaultPalette() {
        activePaletteIndex = 0;
        updatePaletteHeader();
        board.querySelectorAll('.tile').forEach(el => {
          setIndex(el, 0);
          applyGoldOverlay(el);
        });
        separatorPx = 3;
        applySeparator();
      }
      function switchPalette(backwards = false) {
        const len = PALETTES.length;
        activePaletteIndex = (activePaletteIndex + (backwards ? -1 : 1) + len) % len;
        updatePaletteHeader();
        const m = palette().length;
        board.querySelectorAll('.tile').forEach(el => {
          if (!el.dataset.goldOverlay) {
            const k = getIndex(el);
            el.style.background = palette()[((k % m) + m) % m];
          }
        });
      }
      function resizeGrid() {
        const input = prompt('◊î◊õ◊†◊° n (◊ô◊ë◊†◊î n√ón ◊ï◊ô◊ê◊§◊° ◊ú◊ñ◊î◊ë):', String(n));
        if (input === null) return;
        const value = parseInt(String(input).trim(), 10);
        if (!Number.isFinite(value) || value <= 0) return;
        n = value; initialBuildGoldOverlay = true; buildBoard(n);
        applySeparator();
      }

      async function savePNG() {
        board.querySelectorAll('.ring-inset').forEach(el => el.classList.remove('ring-inset', 'ring-4', 'ring-white/90'));
        try {
          const canvas = await html2canvas(board, { backgroundColor: '#000000', scale: 2 });
          const link = document.createElement('a');
          link.download = 'board.png';
          link.href = canvas.toDataURL('image/png');
          link.click();
        } catch (err) {
          console.error("Failed to save PNG:", err);
        }
      }

      // ---- Pointer interactions ----
      const HOLD_DELAY = 200, CYCLE_INTERVAL = 80, DRAG_THRESHOLD = 8;
      const pointerState = { id: null, downEl: null, downX: 0, downY: 0, longPressTimer: null, cyclingInterval: null, suppressClick: false, isDragging: false, dragSource: null, currentTarget: null };

      function onPointerDown(e) {
        const el = e.target.closest('.tile'); if (!el) return;
        e.preventDefault();
        el.setPointerCapture(e.pointerId);
        Object.assign(pointerState, { id: e.pointerId, downEl: el, downX: e.clientX, downY: e.clientY, suppressClick: false, isDragging: false, dragSource: null, currentTarget: null });
        
        pointerState.longPressTimer = setTimeout(() => {
          if (pointerState.isDragging) return;
          pointerState.cyclingInterval = setInterval(() => cycleTile(el, 1), CYCLE_INTERVAL);
        }, HOLD_DELAY);
      }

      function onPointerMove(e) {
        if (pointerState.id !== e.pointerId) return;
        const dist = Math.hypot(e.clientX - pointerState.downX, e.clientY - pointerState.downY);
        
        if (!pointerState.isDragging && dist >= DRAG_THRESHOLD) {
          clearTimeout(pointerState.longPressTimer);
          clearInterval(pointerState.cyclingInterval);
          pointerState.longPressTimer = null;
          pointerState.cyclingInterval = null;
          pointerState.isDragging = true;
          pointerState.dragSource = pointerState.downEl;
          pointerState.suppressClick = true;
        }

        if (pointerState.isDragging) {
          const targetEl = document.elementFromPoint(e.clientX, e.clientY)?.closest('.tile');
          if (pointerState.currentTarget !== targetEl) {
            pointerState.currentTarget?.classList.remove('ring-4', 'ring-white');
            pointerState.currentTarget = targetEl;
            targetEl?.classList.add('ring-4', 'ring-white');
          }
        }
      }

      function onPointerUp(e) {
        clearTimeout(pointerState.longPressTimer);
        if (pointerState.cyclingInterval) {
          clearInterval(pointerState.cyclingInterval);
          pointerState.suppressClick = true;
        }

        if (pointerState.isDragging) {
          if (pointerState.currentTarget) {
            clearGoldOverlay(pointerState.currentTarget);
            setIndex(pointerState.currentTarget, getIndex(pointerState.dragSource));
            pointerState.currentTarget.classList.remove('ring-4', 'ring-white');
          }
        } else if (!pointerState.suppressClick && e.target.closest('.tile')) {
          cycleTile(e.target.closest('.tile'), 1);
        }
        
        pointerState.id = null;
      }
      
      board.addEventListener('pointerdown', onPointerDown);
      board.addEventListener('pointermove', onPointerMove);
      board.addEventListener('pointerup', onPointerUp);
      board.addEventListener('pointercancel', onPointerUp); // Treat cancel as up

      // ---- Buttons ----
      document.getElementById('btnRandom').addEventListener('click', randomizeAll);
      document.getElementById('btnPalette').addEventListener('click', (e) => {
          if (e.shiftKey) {
              const i = PALETTES.findIndex(p => p.name === "Dreamer's Soul");
              if (i !== -1) {
                  activePaletteIndex = (i - 1 + PALETTES.length) % PALETTES.length;
              }
          }
          switchPalette();
      });
      document.getElementById('btnReset').addEventListener('click', resetToGoldAndDefaultPalette);
      document.getElementById('btnResize').addEventListener('click', resizeGrid);
      document.getElementById('btnSave').addEventListener('click', savePNG);
      btnSeparator.addEventListener('click', (e) => cycleSeparator(!e.shiftKey));

      // ---- Init ----
      buildBoard(n);
      updatePaletteHeader();
      applySeparator();
    })();
  </script>
</body>
</html>
